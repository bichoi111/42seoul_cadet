## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [라이브러리란?](#라이브러리란)
    - [정적 라이브러리와 공유 라이브러리](#정적-라이브러리와-공유-라이브러리)
        - [정적 라이브러리](#정적-라이브러리)
        - [공유 라이브러리](#공유-라이브러리) 
        - [정적 라이브러리와 공유 라이브러리 차이점](#정적-라이브러리-vs-공유-라이브러리)
    - [정적 라이브러리 만들기](#gcc로-정적-라이브러리-파일-만들기)
    - [자주 쓰이는 ar 명령어 옵션](#자주-쓰이는-ar-명령어-옵션)
    - [예제](#라이브러리-예제)
    - [실제 학습 시간 및 참고 사이트](#기타-세부-사항)
- [7. 학습 내용에 대한 개인적인 총평](#7-학습-내용에-대한-개인적인-총평)
- [8. 다음 학습 계획](#8-다음-학습-계획)  
<br/> 

## 1. 학습 날짜
* 2021-01-07(목)<br/><br/>
## 2. 학습 시간
* 17:00 ~ 21:00(자가)<br/><br/>
## 3. 학습 범위 및 주제
* 라이브러리 이해하기
* 정적 라이브러리와 동적 라이브러리 비교
* 정적 라이브러리 예제 살펴보기<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* gcc 컴파일 과정 중 **링크 단계**에서 라이브러리 함수와 오브젝트 파일들을 연결한다. 라이브러리 함수에 대해 알아보자.<br/><br/>
## 6. 상세 학습 내용
## 라이브러리란?
자주 사용되는 유용한 함수에 대한 **오브젝트 파일**을 모아둔 것이 라이브러리로, 사실 라이브러리에는 함수 목록(index)도 포함된다.  
```
// 라이브러리

목록
함수 1의 오브젝트 파일
함수 2의 오브젝트 파일
```
시스템에서 제공하는 라이브러리는 **/usr/lib** 디렉토리에 있으니 확인해보면 된다.  
아주 많은 라이브러리가 있는데, 이름은 lib로 시작하고 `ar` 명령어에 의해 생성되므로 확장자는 `.a`다.  

이 중에서 `libc.a`는 표준 라이브러리고 `libm.a`는 수치 연산 라이브러리다.  
ar 명령어를 이용하면 libc.a가 어떠한 오브젝트 파일로 이루어졌는지 알 수 있다.  
ar 명령어의 `t` 옵션은 .a 파일(아카이브)의 파일리스트를 표시해주는 것이다.  
```
$ ar t libc.a
```
<br>

---
<br>

## 정적 라이브러리와 공유 라이브러리
### 정적 라이브러리
- 여러 프로그램에서 사용되는 함수를 포함하는 오브젝트 파일을 하나의 파일로 다룰 수 있도록 정리해 놓은 것.  

- 프로그램을 작성할 때는 소스 파일을 분류해서 일정한 분량으로 나누어 각각의 오브젝트 파일로 컴파일 한 후,  
이를 최종적으로 링크해서 하나의 실행 가능한 파일을 생성한다.  

- 이때 다른 프로그램에서도 사용될 만한 모듈이 여러 개의 오브젝트 파일로 나뉘어 있으면 이것들을 한 덩어리로 다루기가 번거로워진다.    
그래서 생각해낸 것이 아카이브 파일이다.  

- **archive(아카이브) 파일(.a)** : 여러 개의 오브젝트 파일을 하나의 파일로 모아놓은 것.

- `ar` 명령을 사용해 여러 개의 오브젝트 파일을 하나의 아카이브 파일로 합칠 수 있다.

- OS에 따라 ranlib를 사용하면 이 아카이브 파일 내의 오브젝트가 제공하는 심볼 정보를 해시화해서,  
심볼을 제공하는 오브젝트 파일을 효율적으로 검색할 수 있게 된다. (`ar -s`와 같음)  
이와 같은 아카이브 파일을 **정적 라이브러리**라 한다.  
<br>

### 공유 라이브러리 
- 동적 라이브러리
- 정적 라이브러리의 경우 여러 오브젝트 파일의 아카이브였다면,  
공유 라이브러리는 **여러 오브젝트 파일을 하나의 거대한 오브젝트 파일로 만들어 이를 공유할 수 있도록 한 것.**  

- OS의 가상 메모리 관리 시스템이 진보함에 따라, 하나의 파일을 `mmap`등을 이용해 여러 프로세스에서 메모리를 공유해서 참조할 수 있게 되었다.  
이를 활용할 수 있도록 한 것이 공유 라이브러리(or 공유 오브젝트)이다.   
(최근의 OS에서는 일단 메모리맵을 설정해 두는 것만으로 실제로 그 메모리 내용이 참조되기까지  
디스크 액세스를 지연시킬 수 있으므로, 거대한 오브젝트 파일이라도 그다지 문제가 되지 않는다.)  
<br/>

### 정적 라이브러리 VS 공유 라이브러리
- 파일크기  

|라이브러리|설명|
|---|---|
|정적 라이브러리|라이브러리에 포함된 코드를 여러 실행 파일에서 이용하게 되면 각 오브젝트가 매번 복사되므로 용량이 늘어나게 됨.|
|공유 라이브러리|라이브러리 코드 자체는 실행 파일에 복사되지 않고 공유 라이브러리 파일에서만 포함하고 있으므로, 라이브러리 코드를 이용하는 실행 파일이 많더라도 라이브러리 코드 크기만큼의 용량이 증가하지 않음.|  

- 라이브러리 패치(문제가 되는 코드 발견시  

|라이브러리|설명|
|---|---|
|정적 라이브러리|컴파일된 실행 바이너리에 복사된 정적 라이브러리의 오브젝트가 남아 있으므로, 해당 라이브러리를 사용하는 모든 실행 바이너리를 재컴파일 해야 함.|
|공유 라이브러리|공유 라이브러리만 수정하면 됨. 데몬과 같이 장시간 실행하고 있는 프로그램의 경우, 메모리에 로드 되어 있으므로 새로운 공유 라이브러리를 참조하도록 재실행 해야 함.|  

<br/>

---
<br/>

## gcc로 정적 라이브러리 파일 만들기
### 1) GCC 컴파일러를 이용해 obj 파일을 생성한다.
```
$ gcc -c filename1.c filename2.c
```
컴파일에 성공하면 확장자가 .o인 obj파일 (filename1.o filename2.o)이 생성된다.  
<br>

### 2) 생성된 obj 파일을 이용해 라이브러리 파일을 만든다.
즉, 아카이브 파일로 묶어준다.  

라이브러리 작성에 사용하는 명령어는 `ar`이며, 라이브러리 파일 이름은 `lib`로 시작하고, 확장자는 `.a`이다.    
```
$ ar rcs libfile.a filename1.o filename2.o
```
위와 같이
```
<ar 옵션> <생성하고자 하는 라이브러리 이름> <오브젝트 파일들의 이름>
```
을 나열한 후 실행한다.  
<br>
> 윈도우에서 라이브러리 파일의 확장자는 .lib이지만 리눅스에서는 .a 확장자를 지닌다.  

<br>

### 3) 소스파일, 라이브러리 파일 함께 컴파일 하기
- 일반적으로 실행 파일을 만들 때는 소스 코드를 컴파일 하고 만들어진 `obj` 파일을 링커가 하나로 묶어 `.out` (윈도우는 .exe) 파일을 만든다.  
- 정적 라이브러리를 사용하려면 링크 단계에서 링커가 `.a`파일도 같이 묶어서 하나의 `.out` 파일을 만들어야 한다.
- 즉, 컴파일에 성공해 만들어지는 `.out` 파일 안에 lib의 내용이 모두 들어가게 된다.  

GCC컴파일러에게 **링크할 라이브러리를 명시**해주는 작업이 필요하다. 아래의 gcc 명령어 옵션을 사용하면 된다.  
<br/>

#### -l 옵션 (소문자 엘)
```
- 표준 라이브러리가 아닌 라이브러리를 지정한다.
- 링크할 라이브러리를 명시하는 옵션이다.
- 정적 라이브러리를 링크시키는데 사용되며 대상 라이브러리 파일의 이름에서 앞의 lib와 뒤의 .a를 때고 인식한다.
- 예를 들어, libft.a 라이브러리 파일을 링크시키려면 '-lft'로 옵션을 주면 된다.
```
그렇다면 컴파일러가 라이브러리를 찾을 수 있도록 검색할 위치를 명시해 주는 작업도 필요할 것이다.  
기본적으로 리눅스는 `/lib, /usr/lib, /usr/local/lib` 만을 검색해서 라이브러리를 찾는다.  
그러므로 추가적으로 디렉토리를 검색하도록 하려면 아래의 `-L` 옵션을 사용하면 된다.  
<br>

#### -L 옵션
```
- 사용할 라이브러리 위치를 정해주는 옵션이다.
- 사용은 다음과 같이 -L<디렉토리명> 으로 한다.
    
    gcc 소스파일 이름 -L라이브러리위치
    
- `-L.` 은 현재 폴더를 가리킴.
```
`-l` 옵션과 `-L` 옵션을 조합하여 아래와 같이 libmy.a 라이브러리가 있는 디렉토리인 mylib를 지정하면 성공적으로 컴파일이 된다.  
```
$ gcc filename.c -lmy -Lmylib
$ ./a.out
```
<br/>

---
<br/>

## 자주 쓰이는 ar 명령어 옵션
- `r` : 지정한 아카이브로 모듈(obj파일) 추가. 새로운 obj파일이면 추가, 기존 파일이면 치환.  
- `c` : 아카이브(라이브러리 파일) 생성 옵션.
- `s` : 아카이브 인덱스를 생성.

> 아카이브 인덱스를 생성하지 않으면 링크 속도가 느려지고, 시스템 환경에 따라서는 에러가 발생.  

> 아카이브 인덱스는 `nm -s` 로 조회할 수 있다.  

- `d` : 아카이브 모듈을 삭제. 삭제할 파일이 없다면 아카이브를 건들지 않음.
- `v` : verbose mode(동작 내용 출력). 파일 크기나 갱신 시각 등 자세한 정보도 출력.  
- `t` : 아카이브에 있는 파일 리스트 출력
- `x` : 아카이브에서 오브젝트  파일 추출
- ar `tv` [라이브러리 이름] : 아카이브의 내용(권한, 시간정보 등)을 조회
- ar `xv` [라이브러리 이름] : 추출한 파일에 대한 파일명 출력
> ar 명령은 정적 라이브러리를 생성할 때뿐만 아니라, 정적 라이브러리의 기능을 부분적으로 변경하고자 할 경우에도 사용할 수 있다.
> 라이브러리가 모두 오픈 소스로 구성되어 있지 않은 이유 등으로 정적 라이브러리를 처음부터 다시 작성할 수 없는 경우에 편리하게 이용될 수 있다.  

<br/>

---
<br/>

## 라이브러리 예제

#### 라이브러리 직접 만들어 보기
- 우선 다음과 같이 plus.c, minus.c 두 개의 파일을 mylib 디렉토리에 만들자.  
```
// plus.c

int plus(int x, int y)
{
    return (x+y);
}
```

```
// minus.c

int minus(int x, int y)
{
    return (x-y);
}
```
<br/>

- plus.c와 minus.c 파일을 생성했으면 이들 파일에 대한 오브젝트 파일을 생성한다.
```
$ gcc -c plus.c minus.c
$ ls
minus.c minus.o plus.c plus.o
```
그럼 라이브러리 파일을 생성할 준비가 끝났다.  
<br>

- 다음과 같이 **ar** 명령어를 이용하면 plus.o와 minus.o에 대한 libmy.a가 생성되는데,  
`r`옵션은 .a 파일을 생성한다.
```
$ ar r libmy.a plus.o minus.o
```
그리고 라이브러리 파일에 목록을 추가해야 되는데,  
다음과 같이 `s`옵션을 주어 `ar` 명령어를 실행하면 라이브러리 파일이 생성된다.  
```
$ ar s libmy.a
```
<br>

#### -l 옵션 & -L 옵션
 - `-l` 옵션은 표준 라이브러리가 아닌 라이브러리를 사용하고자 할 때 그 라이브러리를 지정해준다.  
```
기능 : 표준 라이브러리가 아닌 라이브러리를 지정한다.
기본형 : gcc 소스파일이름 -l라이브러리이름

라이브러리 이름에는 lib와 .a를 제외한 것만 쓴다.
```
<br>

- `-L` 옵션은 사용할 라이브러리의 위치를 지정해주므로 사용자가 라이브러리 파일을 직접 만들어 사용하거나 새 라이브러리를 내려 받아 사용할 때 이용한다.
```
기능 : 사용할 라이브러리의 위치를 지정한다.
기본형 : gcc 소스파일이름 -L라이브러리위치
```  
<br>

#### 실행을 위한 test 파일 만들기
```c
#include <stdio.h>

int minus(int x, int y); // 이거 안써주면 안됨. 
int plus(int x, int y);

int main()
{
    printf("%d %d\n", minus(2, 3), plus(2, 3));
    return 0;
}
```
<br/>

#### 라이브러리 파일과 test 파일 함께 컴파일
```
$ gcc test.c -lmy -L.

$ ls
a.out libmy.aminus.cminus.oplus.cplus.otest.c

$ ./a.out
5 -1
```
<br>

---
<br>

## 기타 세부 사항
* 실제 학습 시간 : 4시간
* 학습에 참고한 사이트 :   
    * [정적 라이브러리와 공유 라이브러리](https://devanix.tistory.com/184)
    * [정적 vs 동적 라이브러리](https://nicewoong.github.io/development/2018/02/24/c-library-gcc-compile/)
    * [gcc로 정적 라이브러리 파일 만들기](https://velog.io/@hidaehyunlee/GCC%EB%A1%9C-%EC%A0%95%EC%A0%81-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%8C%8C%EC%9D%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0)
    * [라이브러리 예제](https://seamless.tistory.com/2)  

<br>

## 7. 학습 내용에 대한 개인적인 총평
지난 시간 gcc 컴파일 과정을 통해 링크단계에서 라이브러리와 목적파일들을 연결한다고 했는데, 라이브러리에 대한 개념을 확실하게 잡고 가고 싶었다. printf, scanf 등을 포함하는 stdio
<br/>

## 8. 다음 학습 계획
- object 파일을 사용하는 이유를 알아본다.
- 동적 라이브러리 예제를 살펴본다.
