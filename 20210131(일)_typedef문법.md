## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [typedef 문법](#typedef-문법)
    - [typedef 활용](#typedef의-활용)
    - [구조체](#구조체)
- [7. 실제 학습 시간 및 참고 사이트](#7-기타-세부-사항)
- [8. 학습 내용에 대한 개인적인 총평](#8-학습-내용에-대한-개인적인-총평)
- [9. 다음 학습 계획](#9-다음-학습-계획)  
<br/> 

## 1. 학습 날짜
* 2021-01-31(일)<br/><br/>
## 2. 학습 시간
* 16:00 ~ 18:00 (자가)
* 19:00 ~ 20:00 (자가)<br/><br/>
## 3. 학습 범위 및 주제
* typedef와 구조체 문법을 학습한다.
* 구조체와 typedef를 같이 활용하는 방법을 알아본다.<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* typedef와 구조체 문법을 학습한다.<br/><br/>
## 6. 상세 학습 내용
## typedef 문법
`typedef`는 타입을 정의한다는 의미의 'type define'의 줄임 표현이다.  
기존 자료형 중에 자료형 이름의 길이가 긴 경우 프로그래머가 짧고 간결하게 **자료형을 재정의하는 문법이다.**   

> `#define`은 치환 작업을 수행하는 전처리기이고 `typedef`는 기존 자료형을 다른 이름으로 새롭게 정의하는 기능이다.  

<br/>

### - 기본 형식
```
typedef [재정의할 자료형] [재정의된 이름]
```

<br/><br/>

## typedef의 활용
### - 기존 자료형을 단순한 형태의 새 자료형으로 변환하기

기존 자료형의 이름이 길어서 새로운 자료형으로 재정의해야 할 때 새 자료형으로 변환할 수 있다.  
typedef 키워드를 뺀 나머지 부분이 변수를 선언하는 형태와 같다는 특징이 있다.  
그래서 변수 선언과 착각하지 않도록 새 자료형의 이름을 대문자로 적는 경우가 많다.  

```
#include <stdio.h>

// typedef 사용법
typedef unsigned int MyUINT;    // 자료형 재정의

int main()
{
    MyUINT uiNum;    // 재정의된 자료형 사용
    uiNum = 10U;
    printf("uiNum : %u\n", uiNum);
    return 0;
}
```
```
// 실행결과 

uiNum : 10
```
<br/>

### - 배열, 포인터 재정의
`typedef`는 **일반 변수 형식뿐만 아니라 배열, 포인터와 같은 형식도 자료형처럼 재정의할 수 있어서 복잡해 보이는 문법을 쉽게 표현할 수 있다.**  

```
ex)

typedef int ARMYDATA[5];    // int[5]인 자료형
ARMYDATA arTemp = {};       // int arTemp[5]라고 한 것과 같음


ex)

int (*pData)[5];          // int[5]를 가진 *pData 변수

typedef int ARMYDATA[5];
ARMYDATA *pData;          // int (*pData)[5];라고 선언한 것과 같다.
```

<br/>

### - 자료형을 쉽게 바꿀 수 있다.
같은 자료형의 변수를 코드 여러 구문에 선언하다가 변수의 자료형을 변경해야 하는 상황이 온다면, 변수를 찾아가며 일일이 자료형을 수정하는 대신  
`typedef` 문법을 사용하여 자료형을 재정의한 부분만 수정해서 모든 변수의 자료형을 한 번에 쉽게 변경할 수 있다.  

<br/><br/>

---
<br/><br/>

## 구조체
배열을 사용하면 같은 데이터끼리 묶어서 관리할 수 있지만 크기가 같은 종류의 데이터만 그룹으로 묶을 수 있지만,  
**구조체(Structure)는 크기나 형식이 다른 데이터를 그룹으로 묶어 사용할 수 있다.**    
이러한 구조체는 기본 자료형이나 사용자가 정의한 자료형을 그룹으로 묶어서 새로운 자료형을 만들 수 있기 때문에 다양한 형태의 메모리 구조를 만들 수 있다.  

<br/>

### - 구조체로 자료형 정의하기
구조체로 만든 자료형의 크기는 구조체 안에 선언한 요소들의 크기를 모두 더한 것이다.  
구조체의 각 요소가 메모리에 나열되는 순서는 구조체 내부 요소를 선언한 순서와 같다.  

```
struct 구조체 이름
{

자료형1 변수이름1;

자료형2 변수이름2;

자료형3 변수이름3;
.....

};
```
```
(ex)

struct People

{

char name[12];           // 이름 (12byte)

unsigned short int age;  // 나이 (2byte)

float height;            // 키 (4byte)

floar weight;            // 몸무게 (4byte)

                         // 총 22byte

};
```

<br/>

### - 구조체로 만든 자료형으로 변수 선언하기

구조체는 자료형이기 때문에 다양한 형태의 변수를 선언할 수 있다.  

또한 변수를 선언할 때 struct 문법만 사용해서 만든 자료형은 일반 자료형과 달리 변수를 선언할 때 struct 키워드를 반드시 붙여야 하는 불편함이 있다.  
이러한 불편함을 해결하고 구조체 변수를 선언하는 작업을 간편하게 하기 위해서 `typedef` 문법을 사용할 수 있다.  
struct와 typedef는 둘 다 자료형을 정의하는 문법이기 때문이다.  

또한 struct와 typedef를 조합해서 새로운 자운 자료형을 선언하는 형식에서 구조체 이름이 없더라도 typedef의 정의만으로 사용할 수 있다.  

```
(ex)

struct People data; 

struct People freind_list[64];

struct People *p;
```
 
```
(ex)

typedef struct    // struct 뒤에 People 생략

{

char name[12];

unsigned short int nAge;

float height;

float weight;

} People;
```

```
(ex)

People data; 

People freind_list[64];

People *p;
```
<br/>
 

### - 구조체로 선언한 변수 사용하기

배열의 데이터는 각 요소의 크기가 같기 때문에 색인 개념을 사용할 수 있지만 구조체로 묶인 데이터는 각 요소의 크기가 같지 않기 때문에  
사용할 요소의 이름을 직접 적어야 한다. 구조체로 선언한 변수는 `.`(요소 지정) 연산자와 자신이 사용할 요소의 이름을 함께 적어서 사용해야 한다.  

그리고 구조체 자료형에 배열 변수를 선언한 경우에도 각 요소에 접근하는 방식은 같다. 자신이 변경하려는 배열 요소의 색인을 `[][]` 안에 적으면 된다.  
그리고 선택한 배열 요소의 자료형이 구조체이기 때문에 `.`연산자를 사용해 구조체에 포함된 요소를 사용하면 된다.  

또한 구조체로 선언한 변수를 포인터로 사용할 수도 있다. 포인터 변수가 구조체 내부 요소에 접근하려면 `*`(주소 지정)연산자를 사용해서  
변수의 주소로 이동한 다음 `.`(요소지정)연산자를 사용해야 한다. 그런데 `*`연산자가 `.`연산자보다 우선선위가 낮아서 `*`에 `()`괄호를 사용해야 한다.

하지만 구조체로 선언한 변수를 포인터 문법으로 사용할 때마다 불편함이 있어서 연산자 우선순위 문제를 해결할 수 있는 `->`연산자를 제공한다.

- 사용 형식
```
구조체 변수이름 . 사용할요소;
```
<br/>

- 예제
```
(ex) 일반 변수

Person data;

data.age = 28; 

data.height = 124.8;



(ex) 배열 변수

Person friends[15];

friends[1].age = 24;



(ex) 포인터 변수

Person data;

Person *pdata; 

pdata = &data;

(*pdata).age = 24;



(ex)

Person data;

Person *pdata;

pdata = &data;

pdata -> age = 24;
```
<br/>


### - 구조체로 선언한 변수 초기화 하기

배열과 마찬가지로 구조체 문법도 데이터를 묶는 형태이기 때문에 `{ }`를 사용하여 초깃값을 대입하면 된다.  
그리고 **변수를 초기화하는 순서는 구조체 내부에 선언한 구조체 요소의 순서와 초깃값의 순서가 같아야 한다.**  

<br/><br/>

## 7. 기타 세부 사항
* 실제 학습 시간 : 3시간 
* 학습에 참고한 사이트 :
    * https://euncero.tistory.com/16  

<br/>

## 8. 학습 내용에 대한 개인적인 총평
typedef와 구조체가 '형식을 정의한다'는 점에서 같이 비교하여 보고 싶었다. typedef를 구조체에 활용하면 더 간편하게 구조체를 정의할 수 있다는 것을 예제를 통해 살펴보았다. 라피신 때 구조체 과제를 많이 풀지 못했어서, 개념정리도 아직 미흡한데 다음에는 더 다양한 예제들을 다뤄 보면서 구조체를 공부하고 싶다. 카뎃도 벌써 한달이 훌쩍 지났는데, 블랙홀 남은 기간동안 더 집중해서 공부해야겠다.  

<br/>

## 9. 다음 학습 계획
- strcpy, strlcpy 함수를 구현해본다.
- 정적 라이브러리와 Makefile을 만들어서 컴파일해본다.
- 저번 보고서 파일들 컴파일하면 실행파일(a.out)말고도 libft.h.zsh(?) 암튼 하나가 더 생겼는데 이게 뭔지 알아봐야겠다.
