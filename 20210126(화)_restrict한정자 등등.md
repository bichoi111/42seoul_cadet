## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [한정자](#한정자)
        - [volatile](#volatile)
        - [restrict](#restrict)
    - [C99이란?](#c99)
- [7. 실제 학습 시간 및 참고 사이트](#7-기타-세부-사항)
- [8. 학습 내용에 대한 개인적인 총평](#8-학습-내용에-대한-개인적인-총평)
- [9. 다음 학습 계획](#9-다음-학습-계획)  
<br/> 

## 1. 학습 날짜
* 2021-01-26(화)<br/><br/>
## 2. 학습 시간
* 10:00 ~ 12:00 (카페)<br/><br/>
## 3. 학습 범위 및 주제
* volatile, restrict 한정자를 학습한다.
* c99에 대해 조사한다.<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* libft 과제를 분석하며 모르는 내용들(resrict 한정자, C99)을 정리한다.<br/><br/>
## 6. 상세 학습 내용
## - 한정자 
## volatile
- 영어사전 : **변덕스러운, 휘발성의**

어떤 변수가 현재 동작하는 프로그램이 아닌 다른 entity(독립체)에 의해 그 값이 변경될 수도 있다고 컴파일러에게 알린다.  
일반적으로 하드웨어 주소, 또는 동시에 실행되는 여러 프로그램들이 공유하는 데이터에 사용된다.  
이는 컴파일러의 최적화를 지원하기 위해 새로 생성된 키워드이다.  
<br/>

```c
Val1 = x;
/* 변수 x를 사용하지 않는 코드 부분 */
Val2 = x;
```
<br/>

위와 같은 코드가 있을 때 최적화된 컴파일러는 x의 값이 변경되지 않고 두 번 사용되고 있다는 것을 눈치채고,  
**값 x를 레지스터에 임시로 저장하고, val2를 위해 x를 읽어야할 때 원래 메모리 위치 대신에 레지스터에서 값을 읽어 시간을 절약한다.**    
이것을 **캐싱(caching)**이라고 한다. 

일반적으로 캐싱은 두 명령문 사이에서 다른 entity에 의해 x가 변경되지 않을 때만 좋은 최적화이다.  
`volatile` 키워드가 없었던 옛날에는 외부에 의해 x의 값이 변경되었다는 사실을 컴파일러가 알수가 없기에,  
함부로 캐싱을 시도할 수 없었다. 하지만 `volatile`키워드가 정의된 이후부터는, volatile이 사용되지 않으면  
해당 변수는 외부에 의해 변하지 않는 변수라고 가정할 수 있기 때문에 캐싱을 적용할 수 있다.  

하나의 값은 `const`이면서 동시에 `volatile`일 수 있다.  
예를 들면 하드웨어 클록설정은 현재 프로그램에 의해 변경되면 안되므로 const로 만든다.  
하지만 프로그램이 아닌 다른 entity에 의해 변경되므로 volatile로 만든다.  
`volatile const int loc; const volatile int * ploc;`  

<br/>

> 주의할점은 C에서의 volatile 키워드는 컴파일러의 최적화를 위한 것이지 다른 언어에서 사용되는 volatile 키워드와는 의미가 다르다는 것이다.  
> 대개 멀티쓰레드 프로그래밍을할때 데이터가 실시간적으로 반영되는것을 보장하기 위해서 volatile 키워드를 사용하는데  
> C/C++에서는 그런 쓰레드간 실행순서의 차이를 극복하기 위한 수단이 아닌, 블럭 내에서의 코드최적화를 위한 단순한 수단이라는 것.

<br/>

- 다른 예제
```
volatile int num;
volatile int* ptr;
```
> **최적화를 하지 말하주세요!**  
> 딴 곳에서 참조되서 컴파일러님 맘대로 최적화하면 꼬일지도 몰라서 그냥 이대로 살게 내비둬 주세요.  

<br/>

---
<br/>

## restrict
> __최적화를 맘놓고 해도 됩니다!__
> C99의 새로운 표준인데 상당수 컴파일러에서는 아직 지원하지 않기도 함.

<br>

`restrict` 키워드는 **컴파일러가 특정 유형의 코드를 최적화할 수 있도록 허용하여 계산 능력을 향상시킨다.**  
 **`restrict` 키워드는 포인터에만 적용할 수 있다.** 그것은 그 포인터가 어떤 데이터 객체에 접근하는 유일한 최초 수단이라는 것을 나타낸다.  
'유일한'이라는 의미는, 다른 포인터 변수가 해당 데이터를 가리키지 않는다는 것을 명시적으로 나타낸다.  

이를 통하여 해당 변수에서 연산이 여러번 분산되어 이뤄지는 경우 컴파일러는 이를 최적화하여 한 번의 연산으로 변형한다.  
`restrict` 키워드가 없다면 컴파일러는 포인터의 두번에 걸친 사용 사이에 어떤 다른 식별자가 그 데이터를 변경했을 수 있다고 가정해야 한다.  
그러나 restrict 키워드를 사용하면 컴파일러는 더 빠른 방법을 찾을 수 있다.  
<br/>

```c
int * restrict restar = malloc(10);
int ar[10];
int * par = ar;
restar[0] += 1;
restar[0] += 5;
```
`restar[0] += 6`으로 치환된다.  
<br/>

```
ar[0] +=1;
par[0] += 2
ar[0] += 5;
```
`ar[0] += 6`으로 치환되면 좋겠지만 해당 포인터를 가리키는 다른 변수 par를 통해 값이 변경되었으므로(될 수 있으므로) 치환할 수 없다.  

restrict 키워드가 함수 매개변수로 사용되면 이것은 함수의 몸체 안에서 그 포인터가 가리키는 데이터를 다른 식별자로 수정할 수 없다는 것과,  
다른 방법으로는 불가능한 최적화를 컴파일러가 시도할 수 있다는 것을 의미한다.  

예를 들어 `void * memcpy(void * restrict s1, const void * restrict s2, size_t n);` 에서는 각 포인터가 그것이 가리키는 위치에 접근할 수 있는  
유일한 수단이라는 것을 의미한다. 그래서 이 두 포인터는 동일한 데이터 블록에 접근할 수 없다는것이 논리적으로 보장된다.  
<br/>

---
<br/>

## - C99
- 1999년에 나온 표준안
- C99는 C 언어의 현대 개정판이자, C 언어 표준의 과거판인 ISO/IEC 9899:1999의 비공식 이름이다.
- inline 함수의 도입
- C++에서 사용 가능하던 single line comment(//) 사용 가능
- 변수의 선언은 더 이상 함수나 복합 명령어의 시작 부분에 사용할 필요가 없음
- complex와 같은 새로운 자료형 도입
- generic 수학 함수의 추가
- 가변 인수 매크로 도입 
- `restrict` 키워드 도입
- 가변 길이 배열 사용  

<br/><br/>

## 7. 기타 세부 사항
* 실제 학습 시간 : 2시간 
* 학습에 참고한 사이트 :
    * [한정자](https://frontjang.info/entry/C%EC%9D%98-%EA%B8%B0%EC%96%B5%EB%B6%80%EB%A5%98Storage-Class%EC%99%80-%EB%B3%80%EC%88%98-3-%ED%83%80%EC%9E%85-%ED%95%9C%EC%A0%95%EC%9E%90Type-Qualifier)  
    * [C99이란](https://ko.wikipedia.org/wiki/C99)
    * [C99 더 쉬운 설명](https://blog.naver.com/tipsware/221032917097)

<br/>

## 8. 학습 내용에 대한 개인적인 총평
volatile과 restrict 모두 최적화에 쓰이는 키워드 들인데, 깊게 파고들 수록 너무 어려워서 큰 틀만 정리를 해봤다. 과제에서는 restrict 한정자를 프로토타입에 포함시키지 말라고 하는데, 이 점에 유의하여 함수를 재구현해봐야 겠다. 이해가 어려운 단어나 개념에 막힐 때마다 이렇게 정리하는게 도움이 많이 되고 있다. 아쉬운건 이 레포트 과제 제목을 날짜로 설정해야되는 것이 규칙이라는 것... 다시 복습하고 싶을 때나 특정 내용을 열람하고 싶을 때, 하나하나 다 열어봐야 하는 불편함이 있다.   
<br/>

## 9. 다음 학습 계획
- `strlen` 함수를 구현해보고 직접 테스트해본다.  
- `stddef.h`에 대해 알아본다.  
