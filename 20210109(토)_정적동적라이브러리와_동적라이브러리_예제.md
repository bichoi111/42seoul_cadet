## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [정적 라이브러리와 동적 라이브러리](#정적-라이브러리와-동적-라이브러리)
        - [정적 링크 라이브러리](#1-정적-링크-라이브러리-static-link-library)  
        - [동적(공유) 링크 라이브러리](#2-동적-링크-라이브러리-dynamic-link-library)
    - [라이브러리 종류 알아보기](#라이브러리-종류-알아보는-법)
    - [dynamic loader](#dynamic-loader)
    - [동적 라이브러리 예제](#동적-라이브러리-예제)
    - [실제 학습 시간 및 참고 사이트](#기타-세부-사항)
- [7. 학습 내용에 대한 개인적인 총평](#7-학습-내용에-대한-개인적인-총평)
- [8. 다음 학습 계획](#8-다음-학습-계획)  
<br/> 

## 1. 학습 날짜
* 2021-01-09(토)<br/><br/>
## 2. 학습 시간
* 12:00 ~ 16:00(자가)<br/><br/>
## 3. 학습 범위 및 주제
* 정적 라이브러리와 동적 라이브러리의 장단점을 확실히 구분한다.
* 동적 라이브러리 예제를 통해 동적 라이브러리를 생성하는 방법을 학습한다.<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* 동적 라이브러리 예제를 살펴보고, 정적 라이브러리와 비교를 통해 유리한 점을 찾아본다.<br/><br/>
## 6. 상세 학습 내용
## - 정적 라이브러리와 동적 라이브러리
오브젝트 라이브러리는 컴파일된 오브젝트 코드를 담고 있는 파일로, 응용프로그램이 호출할 수 있는 함수들이 들어 있다.  
연관된 함수들을 하나의 오브젝트 라이브러리에 담으면 프로그램 생성과 유지 보수가 편리해진다.  
현대 유닉스 시스템은 '정적 라이브러리'와 '동적 라이브러리'라는 두 가지 오브젝트 라이브러리를 제공한다.  
<br/>

### 1) 정적 링크 라이브러리(Static Link Library) 
#### - 확장자 
- 리눅스 `.a` / 윈도우 `.lib`  
<br/>

#### - 개념
- 컴파일된 오브젝트 모듈의 체계적인 묶음이다.
- **컴파일 시에 함수가 실행파일에 연결**된다.  
- 실행 파일에 함수의 코드가 **복사**되기 때문에 실행파일의 크기가 커지는 단점이 있지만, 실행 파일은 완전한 단독 실행 파일이 된다.  
실행파일에 함수의 코드가 포함되어 있기 때문에 컴파일이 끝나면 **lib 파일이 없어도 프로그램을 실행 할 수 있다.**  

<br/>

#### - 단점
- 정적 라이브러리를 사용할 경우 해당 라이브러리를 사용하는 여러 프로그램이 중복되는 코드가 여기저기 산재해 있어,  
프로그램의 수가 많아질 수록, 혹은 여러 프로그램을 동시에 멀티 태스킹을 해야 할 경우, 각각의 프로그램이 덩치가 커지는 문제가 있다.  
- 정리하면, 정적으로 링크된 각 프로그램들은 **라이브러리에서 추출된 오브젝트 모듈의 복사본을 각각 포함**하고 있기 때문에,  
오브젝트 코드가 중복되어 디스크 공간이 낭비되고, 같은 라이브러리 함수를 쓰는 프로그램들이 동시에 실행될 때 또한 메모리가 낭비된다.  
- 정적 라이브러리는 **라이브러리 함수를 수정해야 하는 상황**일 때, 정적 라이브러리만 수정하는 것으로 끝나는 것이 아니라,  
이미 이러한 라이브러리를 사용한 모든 프로그램들을 찾아내서 **새로이 링크 작업**을 거쳐 실행 파일을 생성하여야 한다.  

<br/>

#### - 장점
- 한번 실행파일을 생성하면 정적 라이브러리가 추후 제거되더라도 이미 생성된 실행 파일을 실행하는 데는 아무런 문제가 없다.  

<br/>

#### - 정적 라이브러리 사용법
- 정적 라이브러리의 함수를 쓰려면, **링크 과정**에서 **해당 정적 라이브러리를 명시**함으로써 해당 라이브러리에 포함되어 있는   
여러 함수를 프로그램 내 코드에 필요한 정의를 **복사**해서 넣는다. 이러한 프로그램을 정적으로 링크된 프로그램이라고 한다.  

<br/>

### 2) 동적 링크 라이브러리(Dynamic Link Library)
#### - 확장자
- 리눅스 `.so` / 윈도우 `.dll`  

<br/>

#### - 개념
- 동적 라이브러리는 다른 말로 공유 라이브러리라고도 불리우며 정적 라이브러리의 문제를 해결하기 위해 만들어 졌다.
- 정적 라이브러리처럼 컴파일 시에 함수가 연결되는 방식이 아닌 **런타임시에 함수가 실행파일에 연결된다.**  

> 런타임 : 컴퓨터 프로그램이 실행되고 있는 동안의 동작  

- 프로그램이 동적 라이브러리와 링크되면, 라이브러리 오브젝트 모듈을 실행 파일로 복사하는 대신,  
링커는 실행파일이 실행 시에 해당 공유 라이브러리가 필요하다는 정보만 **기록**하여 둔다.  
- 이후 실행 파일이 실제로 실행되어 메모리에 올라가면, 동적 라이브러리에 속한 함수가 필요할 때 실제 동적 라이브러리를 참조하여  
필요한 정보를 메모리에 올리게 된다.  
- 이후 다른 프로그램이 실행되며 같은 라이브러리 함수를 참조하고자 하면, **이미 메모리에 존재하는 동적 라이브러리 정보를 참조
하여 바로 링크 작업.** 이러한 특성 때문에 **공유 라이브러리**라고도 불리고 있다.  

<br/>

#### - 단점
- 실행 파일은 함수에 대한 정보만 가지고 있을 뿐 실제 코드를 가지고 있지 않기 때문에 **프로그램 실행시에는 dll 파일이 항상 존재해야 한다.**  
- 라이브러리 수정이 잘못되거나, 삭제될 경우 이 라이브러리를 사용하는 프로그램 또한 오작동, 혹은 실행이 불가능해진다.  

<br/>

#### -장점
- 실행파일에는 호출할 함수의 정보만 포함되고 실제 함수 코드는 복사되지 않으므로 실행 파일의 크기가 작아진다.  
- 수정이 필요할 경우 라이브러리만을 수정하여도 기존의 프로그램들이 수정된 라이브러리를 사용한다는 점에서 유지보수가 매우 쉬운 편에 속한다.  

<br/>

---
<br/>

## - 라이브러리 종류 알아보는 법
 어떤 프로그램이 공유 라이브러리를 사용하는지 알아보려면, 리눅스에서는 `file`명령어를 사용하면 된다.  
 - 공유 라이브러리를 사용하는 경우
 ```
 $ file a.out

a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, not stripped
 ```
 - 정적 라이브러리를 사용하는 경우
```
$ file a.out

a.out: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.18, not stripped
```
<br>

---
<br/>

## - dynamic loader
- 공유 라이브러리와 연결된 프로그램을 실행하면 내부적으로 `dynamic loader`라는 프로그램이 먼저 동작하여, 다음과 같은 작업을 실행한다.
```
1. dynamic link 된 공유 라이브러리를 찾아서 메모리에 로딩
2. entry function (C 언어일 경우 main 함수)를 찾아서 호출
3. 프로그램 실행
```
<br/>

- 각 운영체제 로더 이름

|운영체제|로더|
|---|---|
|Linux|ld.so 또는 ld-linux.so|
|Mac OS X|dyld|
|Solaris|ld.so|
|HP-UX|dld.so|

<br/>

---
<br/>

## - 동적 라이브러리 예제
공유라이브러리는 여러 오브젝트 파일을 하나의 오브젝트 파일로 만들어서 공유하는 방식을 이용한다.  
정적라이브러리처럼 함수코드가 실행파일 내부에 포함되는 것이 아니라 **참조**하는 방식으로 이용된다.  
<br/>

### 1) 라이브러리로 쓸 함수가 포함된 소스파일 작성
```
// mylib.h

#include <stdio.h>

void func(int a, int b)
{
    int sum = 0;
    sum = a + b;
    printf("sum = %d\n",sum);
}
```
<br/>

### 2) 컴파일 및 공유 라이브러리 생성

- 독립적인 코드로 만들기 위해 gcc에서 `-fPIC`옵션을 사용하여 컴파일 한 뒤, `-shared`옵션을 이용해서 공유 라이브러리를 생성.
<br/>

```
$ gcc -fPIC -c mylib.c
$ gcc -shared -o libmy.so mylib.o
$ ls
libmy.so    mymlib.c    mylib.o
```
- `-fPIC` 옵션은 위치 독립적인 코드를 생성하는 옵션이다.  
- `-fpic`(소문자) 은 플랫폼에 제약이 생기지만 빠르고 가볍다.  
- `-fPIC`(대문자) 은 플랫폼에 제약이 없지만 무겁고 느리다. 대부분 이걸 사용.  
- `-c` 옵션 : 오브젝트 파일을 생성한다.

> 생성된 공유 라이브러리 파일은 등록을 해주어야 사용이 가능하다.

<br/>

### 3) 공유 라이브러리 등록
아래의 경로 파일에 가보면 include 할 수 있는 문법(?) 같은 것이 보인다.  
저 경로(`/etc/ld.so.conf.d/`)에 `.conf`파일을 생성하면 된다.
```
$ cat /etc/ld.so.conf
include /etc/ld.so.conf.d/*.conf
```
`/etc/ld.so.conf.d/라이브러리명.conf` 로 파일 생성 후 내부에 자신이 만든 공유라이브러리 파일(`.so`)의 **전체경로를 등록**해준다.
```
~/Desktop/pwm_study_code/library/share$ cat /etc/ld.so.conf.d/mylib.conf

/root/Desktop/pwn_study_code/library/share/
```
```
$ ldconfig
```
`ldconfig`명령어를 이용해서 캐쉬를 갱신해준다.  
이렇게 하면 공유 라이브러리를 다른 모든 실행 파일에서 사용할 수 있게 된다.  
<br/>

### 4) test 파일 만들기
```c
// test.c

#include <stdio.h>

void func(int a, int b);
int main()
{
    printf("start!\n");
    func(20, 20);
    printf("end!\n");
    return (0);
}
```
<br/>

### 5) 공유라이브러리 컴파일
```
$ gcc test.c -o dynamic -lmy -L.
$ ./dynamic
start!
sum = 40
end!
```
<br/>

### 6) ldd 명령어
- `ldd` 명령어를 이용하면 해당 프로그램에서 요구하는 공유 라이브러리들을 볼 수 있다.  
우리가 방금 만들고 등록해놓은 라이브러리 파일을 참조하는 것을 확인할 수 있다.  
```
$ ldd dynamic
```
<br>

> 공유 라이브러리를 링크한 실행 파일을 실행하게 되는 경우에는 `동적 링커 로더(ld.so)`가    
> 해당 실행 파일에서 필요한 공유 라이브러리를 찾아내 실행시 해당 프로세스의 메모리 맵을 조작하여  
> 공유라이브러리와 실행 바이너리가 같은 프로세스 공간을 사용하도록 해준다.  

<br/>

> 그러므로 실행파일 내부에 라이브러리 코드가 포함되있지 않고 공유라이브러리에만 존재하기 때문에  
> 실행파일 배포시 함께 배포해야한다. 그렇지 않으면 라이브러리를 찾을 수 없다는 에러메세지와 함께 실행되지 않는다.  

출처: https://xn--vj5b11biyw.kr/126 [Ho_use]  

<br/>

### 7) 공유라이브러리 gcc 옵션
- `-shared`는 공유 라이브러리 `.so` 파일 생성  
    ex) gcc -shared -o libtest.so mylib.o
- 공유 라이브러리 링킹  
    ex) gcc test.c -o dynamic -ltest -L.  
    
    > - `-l` 다음은 `.so`파일의 lib 다음의 파일명.  
    > `.so` 파일을 생성할 때 파일명을 되도록 **lib**로 시작하는 것이 좋다!  
    > 그 이유는 `동적 링커 로더(ld.so)`가 해당 실행파일에 필요한 공유라이브러리를 찾을 때 `/etc/ld.so.conf.d/`에서  
    > 우리가 생성한 `.conf`파일에 등록된 경로에서 `.so`파일을 탐색하는데 이 때 lib로 시작하는 파일 이름으로 검색하는 것 같다.  
    > 예를 들어 libtt.so파일이 있다고 가정하면 우리가 공유라이브러리 링킹 시 gcc에서 컴파일시 -l 옵션을 주는데 이 때,  
    > `-ltt`(.so의 파일명중 lib를 제외한 파일명) 이런 식으로 옵션을 주게된다.  
    > 하지만 .so파일이름을 tt.so처럼 만들어서 실험해보니 제대로 컴파일이 이루어지지 않았다.  
    > 그러므로 동적 링크 로더는  `/etc/ld.so.conf.d/.conf` 경로에 있는 파일 중 lib로시작하는 파일을 찾게되는 것 같다.  

<br/>

---
<br/>

## - 기타 세부 사항
* 실제 학습 시간 : 4시간 
* 학습에 참고한 사이트 :
    * [정적, 동적라이브러리 개념 1](https://hsunnystory.tistory.com/109)  [정적, 동적라이브러리 개념 2](https://yjcode.tistory.com/9)
    * [동적 라이브러리 예제](https://xn--vj5b11biyw.kr/126)
    * [dynamic로더](https://www.lesstif.com/software-architect/shared-library-linker-loader-12943542.html)

<br>

## 7. 학습 내용에 대한 개인적인 총평
동적 라이브러리와 정적 라이브러리의 장단점을 비교해 보고, 동적 라이브러리 예제를 살펴보았는데 정적 라이브러리를 만드는 것 보다 복잡한 것 같다. 더 유용하게 쓸 수 있는 것은 동적 라이브러리 같은데, 이해가 잘 안된다. 또 공유 라이브러리를 만들 때는 `-fPIC` 옵션을 사용하는게 좋은데, `-fPIC` 옵션에 대해 찾아보아도 잘 이해가 되지 않았다. [fPIC 옵션](https://devanix.tistory.com/198) 4시간을 찾아봐도 잘 이해가 안되어서 실망스럽지만, 앞으로 실전으로 겪어보면서 정리해 봐야겠다.  
<br/>

## 8. 다음 학습 계획
- Makefile 예제를 학습하고, Makefile을 이해한다.
