## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [순환 make](#--순환-make)  
    - [불필요한 재컴파일 막기](#--불필요한-재컴파일-막기)
    - [make 옵션](#--make-옵션)
    - [실제 학습 시간 및 참고 사이트](#--기타-세부-사항)
- [7. 학습 내용에 대한 개인적인 총평](#7-학습-내용에-대한-개인적인-총평)
- [8. 다음 학습 계획](#8-다음-학습-계획)  
<br/> 

## 1. 학습 날짜
* 2021-01-14(목)<br/><br/>
## 2. 학습 시간
* 12:00 ~ 14:00(자가)<br/><br/>
## 3. 학습 범위 및 주제
* 여러 Makefile을 동작시키는 방법을 알아본다.  
* 불필요한 재컴파일을 막기위해 사용하는 옵션을 알아본다.  
* make에서 자주 쓰이는 옵션들을 학습하고 직접 실행해 본다.<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* make의 심화 학습과 함께 직접 실행해 봄으로써 make의 동작에 익숙해진다.<br/><br/>

## 6. 상세 학습 내용
## - 순환 make
규모가 큰 프로그램들은 파일들이 하나의 디렉토리에 있지 않는 경우가 많다.  
여러 개의 서브시스템이 전체 시스템을 구성한다고 가정하면 각 서브시스템에 Makefile이 존재한다. (서브시스템 = 서브디렉토리)  
따라서 여러 개의 Makefile을 동작시킬 필요가 있도록 Makefile을 고쳐 보자. 서브 디렉토리에 있는 Makefile을 동작시키는 방법은 의외로 간단하다.  
아래의 간단한 예제를 보자.  
```
subsystem:
    cd subdir; $(MAKE)    ...(1)
    
subsystem:
    $(MAKE) -C subdir    ...(2)
```
위의 예제에서 (1)과 (2)는 동일한 명령을 수행한다. (1)을 기존으로 동작을 한번 묘사해보자.  
우리가 만들 시스템의 타겟이 `subsystem`이다. (이름은 아무래도 상관없다.)  
<br/>
**우선 subdir이라는 곳으로 가서, 거기에 있는 Makefile을 동작시키게 된다.**  
MAKE라는 것은 그냥 make라는 명령어를 표시하는 매크로일 뿐. 그럼 완전한 예제를 한번 구성해 보기로 한다.  
```
.SUFFIXES : .c .o
CC = gcc
CFLAGS = -02 -g

all : DataBase Test    # 요기에 집중

DataBase :
    cd db ; $(MAKE)    # db로 이동해서 make 실행

Test :
    cd test ; $(MAKE)    # test로 이동해서 make 실행
```
위의 예제에서 db, test 디렉토리에 있는 Makefile은 지금까지 우리가 공부했던 Makefile과 거의 흡사하다고 가정하자.  
위의 Makefile을 실행시켜 본다.  
> DataBase와 Test로 이루어진 큰 프로그램은 어떻게 실행을 하지...?  
 
```
$ make
cd db ; make
make[1]: Entering directory`/home/raxis/TEST/src'
gcc -O2 -g -c DBopen.c -o DBopen.o
gcc -O2 -g -c DBread.c -o DBread.o
gcc -O2 -g -c DBwrite.c -o DBwrite.o
make[1]: Leaving directory `/home/windows/TEST/src'
cd test ; make
make[1]: Entering directory `/home/raxis/TEST/test'
gcc -O2 -g -c test.c -o test.o
make[1]: Leaving directory `/home/windows/TEST/test'
```
위의 가상 실행을 보면 우선 db로 가서 거기의 Makefile을 수행시키고, 다음에는 test로 가서 Makefile을 실행시킴을 볼 수 있다.  
우선은 단순하게 컴파일만 시켰는데, 다르게 한번 생각해 보자.  
db 디렉토리에서의 최종 타겟으로 가령 db.a을 만들어 내고 test 디렉토리에서 이를 링크 시킨다고 생각하면 꽤 괜찮은 시나리오가 될 것이다.  
위에서 `1`이라고 나타난 것은 현재의 레벨을 의미한다. 원래 디렉토리의 레벨이 `0`이고, 여기서는 레벨이 하나 더 내려갔으므로 `1`이라고 표시한 것이다.  
<br/>

---
<br/>

## - 불필요한 재컴파일 막기
의존 관계 규칙에 의해 하나가 바뀌면 그에 영향받는 모든 파일이 바뀐다고 앞에서 말했다.  
그러나 다른 파일들에게 아무 영향을 주지 않도록 수정하였는데도 재컴파일을 시도한다면 시간 낭비가 될 수도 있다.  
<br/>
가령 모든 `.c` 파일에서 includ 하는 헤더 파일에서 새로운 #define PI 3.14 라고 정의를 했다고 가정하자.  
그리고 PI라는 것은 아무 곳에서도 사용을 하지 않는다.  
<br/>
이때는 `make -t`라고 해보자.  
**-t 는 touch를 의미하는 옵션으로써 컴파일을 하지 않는 대신 파일의 생성 날짜만 가장 최근으로 바꾸어 놓는다.**    
새로 컴파일 된 것처럼 처리를 하는 것이다. touch 유틸리티 명렁어에 익숙한 사람이라면 이해할 것이다.  
touch는 파일의 생성 날짜를 현재로 바꾸어 주는 간단한 유틸리티이다.  
<br/>

---
<br/>

## - make 옵션
make에서 거의 모든 것은 Makefile 내부에서 모두 지정을 할 수 있다. 그 중 일부를 make의 실행시에 옵션으로 통해서 줄 수도 있다.  

|옵션|설명|
|:----:|:----|
|-C dir|위에서도 밝혔듯 Makefile을 계속 읽지 말고 우선은 dir로 이동하라는 것. **순환 make에 사용된다.**|
|-d|Makefile을 수행하면서 각종 정보를 모조리 출력해 준다. (-debug) 출력량이 장난 아님...<br/> 결과를 파일로 저장해서 읽어보면 make의 동작을 대충 이해할 수 있다.|  
|-h|옵션에 관한 도움말을 출력한다. (-help)|
|-f file|file에 해당하는 파일을 Makefile로써 취급한다. (-file)|
|-r|내장하고 있는 각종 규칙(Suffix rule 등)을 없는 것으로 (-no-builtin-rules)간주한다. 따라서 사용자가 규칙을 새롭게 정의해 주어야 한다.|
|-t|파일의 생성 날짜를 현재 시간으로 갱신한다. (-touch)|
|-v|make의 버전을 출력한다. (-version)|
|-p|make에서 내부적으로 세팅되어 있는 값들을 출력한다. (-print-data-base)|
|-k|make는 에러가 발생하면 도중에 실행을 포기하게 되는데 (-keep-going) -k는 에러가 나더더라도 멈추지 말고 계속 진행하라는 뜻|  

<br/>

---
<br/>

## - 기타 세부 사항
* 실제 학습 시간 : 2시간 
* 학습에 참고한 사이트 :
    * ['순환 make' & 'make -t'](http://doc.kldp.org/KoreanDoc/html/GNU-Make/GNU-Make-4.html)  
    * [make 중요 옵션](http://doc.kldp.org/KoreanDoc/html/GNU-Make/GNU-Make-5.html)  
<br/>

## 7. 학습 내용에 대한 개인적인 총평
이번주 내내 make, Makefile 위주로 공부한 내용들을 정리하고 있는데, 아직도 학습할 게 많이 남은 것 같다. 사실 오늘은 42 instruction에 명시되어있는 `all, clean, fclean, re` 이런 규칙들을 정리하려고 했는데, 찾다보니 make에 대해 미처 몰랐던 부분들을 공부하게 되었다. '순환 make'파트에서 하나의 큰 시스템을 이루는 여러 서브 시스템에 포함되어있는 Makefile들을 실행하는 방법을 알아봤는데, 위에 있는 예제와 같이 실행을 하고나면 각 서브시스템에 있는 파일들이 컴파일이 될 것이다. 그렇다면 그 서브 시스템들로 이루어진 큰 프로그램은 어떻게 실행을 해야할까? '순환 make'를 통해 큰 프로그램에 필요한 모든 파일들은 컴파일 되었다고 본다면 이번에는 그 각각의 서브시스템의 파일들을 연결시켜서 하나의 실행파일로 만들면 될 것인데... link를 해주면 되는건가? 어떤 개념부터 모르는건지도 이제는 잘 모르겠다.       
<br/>

## 8. 다음 학습 계획
- 42서울 과제에 필요한 $(NAME), clean, fclean, re, all의 개념을 학습한다.
