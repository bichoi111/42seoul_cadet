## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [깃(git)이란?](#깃-git-이란) 
    - [깃을 사용하는 이유?](#깃을-사용하는-이유)  
    - [기본 용어](#기본-용어)
    - [주요 명령어](#주요-명령어)
    - [깃의 장단점](#깃의-장단점)
    - [branch 추가 공부](#branch-추가-공부)
    - [실제 학습 시간 및 참고 사이트](#기타-세부-사항)
- [7. 학습 내용에 대한 개인적인 총평](#7-학습-내용에-대한-개인적인-총평)
- [8. 다음 학습 계획](#8-다음-학습-계획)  
<br/> 
## 1. 학습 날짜
* 2020-12-24(목)<br/><br/>
## 2. 학습 시간
* 16:00 ~ 19:20(자가)<br/><br/>
## 3. 학습 범위 및 주제
* 깃을 쓰는 이유와 깃의 장단점을 알아본다.
* 기본적인 용어 및 주요 명령어를 정리 및 숙지한다.
* 예시를 통해 branch를 이해한다.<br/><br/>
## 4. 동료 학습 방법
* 해당 없음<br/><br/>
## 5. 학습 목표
* 깃의 사용 목적을 알고 앞으로 깃을 어떻게 활용할 것인지 생각해 본다.<br/><br/>
## 6. 상세 학습 내용
### 깃(git)이란?
- [나무위키-git](https://namu.wiki/w/Git) , [위키백과-git](https://ko.wikipedia.org/wiki/%EA%B9%83_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)) 

깃 허브는 '깃 git'을 쉽고 편리하고 잘 제공하는 곳이다. 그렇다면 '깃 git'이란?  

깃허브의 심장에서 작동되는 소프트웨어인 깃(Git: 재수없고 멍청한 놈, 자식)을 만든 유명한 소프트웨어 개발자 리누스 토발즈에 감사한다.  
__깃은 프로젝트의 어떤 부분도 겹쳐쓰지 않게 프로젝트의 변경을 관리하는 버전관리 소프트웨어이다.__  
__깃(Git)은 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템이다.__  
<br/>
### 깃을 사용하는 이유?
당신과 동료가 동시에 같은 웹사이트에서 페이지를 업데이트하고 있다고 하자. 당신이 무언가를 변경하고 저장한 다음 웹사이트에 그것을 업로드한다.  
지금까지는 좋았다. __문제는 동료가 동시에 같은 페이지에서 작업할 때이다. 누군가의 작업은 겹쳐쓰여질 것이고 지워질 것이다.___  

__깃과 같은 버전관리 앱은 그런 일을 방지한다.__ 당신과 동료는 같은 페이지에 각자의 수정사항을 각각 업로드할 수 있고, 깃은 두 개의 복사본을 저장한다. 나중에, 당신들은 그대로 어떤 작업도 잃어버리지 않고 변경사항들을 병합할 수 있다. 깃은 이전에 만들어진 모든 변경사항의 __“스냅샷”__ 을 저장하기 때문에 이전 시점의 어떤 버전으로 되돌릴 수도 있다.  

깃을 사용할 때 어려운 점은 90년대 해커와 같이 코드를 타이핑하는 명령어(커맨드 라인 - 맥 사용자라면 터미널)를 사용하여 접근해야하는 것이다. 이것은 요즘 컴퓨터 사용자에겐 까다로운 일일 수는 있다.  
<br/>
__깃허브는 두 가지 방식으로 깃을 더 편리하게 해준다.__  
- 깃허브 소트프웨어를 다운로드하면, 로컬에서 당신의 프로젝트를 관리할 수 있게하는 비주얼 인터페이스를 제공한다.
- Github.com에 계정을 생성하면 웹에서 프로젝트를 버전관리할 수 있으며, 평가측정 등의 소셜 네트워크 기능을 사용할 수 있다.  

다른 깃허브 사용자의 프로젝트를 둘러볼 수 있고, 그것들을 변경하거나 배우기 위해 자신만의 복사본을 다운로드할 수도 있다. 다른 사용자도 당신의 공개 프로젝트에 대해 같은 걸 할 수 있으며 에러를 발견해서 해결책을 제안할 수도 있다. 어느 경우든, __깃이 모든 변경사항에 대한 “스냅샷”을 저장하기 때문에 어떤 데이터도 잃어버리지 않는다.__  
<br/>
### 기본 용어
- __버전관리 소프트웨어__  

__버전관리(Version Control)__: 기본적으로, 깃이 서비스되도록 고안된 목적. MS 워드 작업할 때, 저장하면 이전 화일 위에 겹쳐쓰거나 여러 버전으로 나누어 저장한다. 깃을 사용하면 그럴 필요가 없다. _프로젝트 히스토리의 모든 시점의 “스냅샷”을 유지하므로, 결코 잃어버리거나 겹쳐쓰지 않을 수 있다._

개발 중 변경 내역을 추적할 있도록 개발된 소프트웨어를 말한다.   
즉, 버전별로 저장되어 변경된 사항을 알 수 있게 한다. 이전 버전과 차이를 알 수 있고, 이전 버전을 볼 수 있다.  

작은 규모의 프로젝트면 모르겠지만 많은 개발자가 함께 개발해 나가는 프로젝트에서 많은 파일, 많은 소스코드가 변경되고 추가된다면 이 '버전관리 프로그램'은 굉장한 힘을 발휘한다.  

- __커맨드 라인(Command Line)__  

깃 명령어를 입력할 때 사용하는 컴퓨터 프로그램. 맥에선 터미널이라고 한다. PC에선 기본적인 프로그램이 아니어서 처음엔 깃을 다운로드해야 한다.  
두 경우 모두 마우스를 사용하는 것이 아닌 프롬프트로 알려진 텍스트 기반 명령어를 입력한다.  

- __저장소(Repository)__  

프로젝트가 거주(live)할 수 있는 디렉토리나 저장 공간. 깃허브 사용자는 종종 “repo”로 줄여서 사용한다. 당신의 컴퓨터 안의 로컬 폴더가 될 수도 있고, 깃허브나 다른 온라인 호스트의 저장 공간이 될 수도 있다. 저장소 안에 코드 화일, 텍스트 화일, 이미지 화일을 저장하고, 이름붙일 수 있다.

- __커밋(Commit)__

깃에게 파워를 주는 명령이다. 커밋하면, 그 시점의 당신의 저장소의 “스냅샷”을 찍어, 프로젝트를 이전의 어떠한 상태로든 재평가하거나 복원할 수 있는 체크포인트를 가질 수 있다.

- __브랜치(Branch)__

여러 명이 하나의 프로젝트에서 깃 없이 작업하는 것이 얼마나 혼란스러울 것인가?  
일반적으로, 작업자들은 메인 프로젝트의 브랜치를 따와서(branch off), 자신이 변경하고 싶은 자신만의 버전을 만든다. 작업을 끝낸 후, 프로젝트의 메인 디렉토리인 “master”에 브랜치를 다시 “Merge”한다.  
<br/>

### 주요 명령어
깃은 리눅스와 같은 큰 프로젝트를 염두에 두고 디자인되었기 때문에, 깃 명령어는 아주 많다.  
그러나, 깃의 기본을 사용할 때에는 몇 개의 명령어만 알면된다. 모두 “git”이란 단어로 시작된다.

- __git init__ : 깃 저장소를 초기화한다. 저장소나 디렉토리 안에서 이 명령을 실행하기 전까지는 그냥 일반 폴더이다. 이것을 입력한 후에야 추가적인 깃 명령어들을 줄 수 있다.

- __git config__ : “configure”의 준말, 처음에 깃을 설정할 때 가장 유용하다.

- __git help__ : 명령어를 잊어버렸다? 커맨드 라인에 이걸 타이핑하면 21개의 가장 많이 사용하는 깃 명령어들이 나타난다. 좀 더 자세하게 “git help init”이나 다른 용어를 타이핑하여 특정 깃 명령어를 사용하고 설정하는 법을 이해할 수도 있다.

- __git status__ : 저장소 상태를 체크. 어떤 화일이 저장소 안에 있는지, 커밋이 필요한 변경사항이 있는지, 현재 저장소의 어떤 브랜치에서 작업하고 있는지 등을 볼 수 있다.

- __git add__ : 이 명령이 저장소에 새 화일들을 추가하진 않는다. 대신, 깃이 새 화일들을 지켜보게 한다. 화일을 추가하면, 깃의 저장소 “스냅샷”에 포함된다.

- __git commit__ : 깃의 가장 중요한 명령어. 어떤 변경사항이라도 만든 후, 저장소의 “스냅샷”을 찍기 위해 이것을 입력한다. 보통 “git commit -m “Message hear.” 형식으로 사용한다. -m은 명령어의 그 다음 부분을 메시지로 읽어야 한다는 것을 말한다.  

저장소에 내 디렉토리에 있는 모든 파일에 대한 스냅샷을 기록하는 것. 디렉토리 전체를 복사하여 붙여넣는것과 유사하지만, 훨씬 유용한 방법이다!  

Git은 가능한 한 커밋을 가볍게 유지하고자 하기때문에, __커밋할 때마다 디렉토리 전체를 복사하진 않는다. 각 커밋은 저장소의 이전 버전과 다음 버전의 변경내역("delta"라고도 함)을 저장한다.__ 그래서 대부분의 커밋이 그 커밋 위의 부모 커밋을 가리킴.  
```
예로 현재 두번 커밋한 상태.
첫번째 커밋으로 C0, 그 다음으로 C1이라는 어떤 의미있는 변화가 있는 커밋이 있다.

        c0
        ↑
        c1 (master*)
```
여기서 한 번 더 `git commit`하면,  
```
        c0
        ↑
        c1
        ↑
        c2 (master*)
```
우리는 방금 저장소 내용을 변경해서 하나의 커밋으로 저장함. __방금 만든 커밋은 부모는 C1이고, 어떤 커밋을 기반으로 변경된 것인지를 가리킨다.__

- __git branch__ : 여러 협업자와 작업하고 자신만의 변경을 원한다? 이 명령어는 새로운 브랜치를 만들고, 자신만의 변경사항과 화일 추가 등의 커밋 타임라인을 만든다. 내 제목이 명령어 다음에 온다. 새 브랜치를 “cat”으로 부르고 싶으면, git branch cat를 타이핑한다.
```
        c0
        ↑
        c1 (master*)
```
이 상태에서 cat이라는 브랜치를 `git branch cat` 명령어로 추가하면,    
```
        c0
        ↑
        c1 (master*)
           (cat)
```
브랜치 cat이 커밋 C1를 가리킨다. 이 상태에서 `git commit`을 하면,  
```
        c0
        ↑
        c1 (cat)
        ↑
        c2 (mater*)
```
master 브랜치가 움직이고, newImage 브랜치는 이동하지 않았다.  
그건 우리가 새 브랜치 위에 있지 않았었기 때문이다. 별표(\*)가 master에 있었던 것.  

그래서 바로 전 단계에서 `git checkout cat; git commit`을 해줘야 아래와 같이 변경이 새 브런치에 기록된다.
```
        c0
        ↑
        c1 (master)
        ↑
        c2 (cat*)
```

- __git checkout__ : 글자 그대로, 현재 위치하고 있지 않은 저장소를 “체크아웃”할 수 있다. 이것은 체크하길 원하는 저장소로 옮겨가게 해주는 탐색 명령이다. master 브랜치를 들여다 보고 싶으면, git checkout master를 사용할 수 있고, git checkout cats로 또 다른 브랜치를 들여다 볼 수 있다.

- __git merge__ : 브랜치에서 작업을 끝내고, 모든 협업자가 볼 수 있는 master 브랜치로 병합할 수 있다. git merge cats는 “cats” 브랜치에서 만든 모든 변경사항을 master로 추가한다.

- __git push__ : 로컬 컴퓨터에서 작업하고 당신의 커밋을 깃허브에서 온라인으로도 볼 수 있기를 원한다면, 이 명령어로 깃허브에 변경사항을 “push”한다.

- __git pull__ : 로컬 컴퓨터에서 작업할 때, 작업하고 있는 저장소의 최신 버전을 원하면, 이 명령어로 깃허브로부터 변경사항을 다운로드한다(“pull”).

- __git clone__ : 원격 저장소의 파일을 내 pc에 저장할 때  
<br/>
### 깃의 장단점
#### - 장점
1) __오프라인 작업이 가능하다.__  
__git는 저장소를 일단 로컬에 복제하고, 로컬 저장소에 있는 히스토리도 그대로 유지__ 되므로, 서버에서 새 자료를 받아올 수 없을 뿐이지 이외에는 오프라인 상태에서도 대부분의 형상관리 기능을 이용할 수 있다. 일종의 로컬 서버로 작용하는 셈.  

2) __속도가 빠르다.__ 각각의 개발자들이 모두 분산처리 서버의 주인이 되는 셈이므로 서버가 직접 해야 될 일들이 많이 줄어든다.  

3) 일시적인 서버 장애가 있어도 개발을 계속할 수 있다. 로컬 저장소를 이용하면 되기 때문.  

4) 서버와 클라이언트 뿐인 기존 형상관리에 비해 분산처리 구조를 유연하게 세울 수 있다. 중간 서버를 둔다든지, 부서별로 따로 서버를 둔다든지 하는 구성이 자유롭게 가능.  

5) __가지치기(branch)가 비교적 가볍다.__ 가지치기 자체를 git의 장점으로 꼽기도 하지만 이는 현존하는 대부분의 형상관리 도구가 지원하는 기능이다. 실질적인 차이는 그 구현 방법에 있다고 봐야 한다. git는 브랜칭이 매우 쉽고 가벼워 원하는 만큼 별 제약 없이 생성하고 삭제할 수가 있다. git만 사용해오던 사람은 당연하게 느껴질 것이고 이게 왜 장점인지조차 모를 수 있겠지만, 기존 형상관리 도구를 사용하던 사람들은 브랜칭 하나 하려고 수 시간의 미팅을 해야 하던 때도 있었다.  

6) __병합(merge)에서 문제가 덜 발생한다.__ 서버의 자료를 가져와(fetch) 로컬에서 병합하고 이를 다시 올리는 형태이기 때문. 물론 아예 문제가 발생하지 않을 수는 없으나, 이러한 구조 덕분에 예기치 못하게 발생하는 병합 문제 발생 빈도가 낮아진다.  

7) 스테이징을 지원한다. 단순히 커밋되지 않은 로컬 변동사항을 얘기하는 것이 아니고, 아예 커밋하기 전에 사용해야 하는 스테이징 단계가 따로 있다. 물론 이를 사용하지 않고 다른 형상관리 도구처럼 바로 커밋하는 식으로 사용할 수도 있다.   

8) 직접 호스팅을 할 경우 상업용 용도로도 무료로 이용 가능한 방법이 존재한다.  

#### - 단점
1) 기존 형상관리 도구에 비해 덜 직관적이고 배우기 어렵다.  

2) __한 번에 여러 브랜치나 여러 태그에 걸쳐서 커밋을 할 수 없다.__ 내가 만든 사소한 변동사항이 다른 브랜치에 자동적으로 알려지지 않고, 나중에 취합하는 시점이 돼서야 반영된다.

3) 하나의 저장소가 하나의 프로젝트 전체를 의미하는 것으로 강제되어 있어 일부만 브랜칭을 한다든지 클론을 한다든지 하는 일을 할 수 없다. 정책적인 부분이라 관점에 따라 장점이 될 수도 있겠지만, 해당 기능이 꼭 필요한 사람이라면 단점이 될 수 있다.  

4) push를 했다 해서 커밋 히스토리가 영원히 안전하게 저장된다고 장담할 수 없다. 중앙 집중형 형상관리에서는 일단 체크인을 하고 나면 서버에 문제가 생기지 않는 한에는 항상 안전하고 언제든 과거 기록을 볼 수 있으나, git에서는 push를 한 내용이라 하더라도 해당 브랜치가 다른 브랜치에 병합되기 전에 삭제돼버리면 나중에 해당 내용에 접근할 수 없다.

5) 커밋 ID가 긴 16진수 숫자(SHA-1 해시값)라 기억하기가 어렵고 항상 복사-붙여넣기를 해야 한다. 딱히 큰 문제는 아니지만 단순한 10진수 숫자로만 구성되어 있는 TFS등에 비해 복잡한 것은 사실.

6) 역시 소소하지만 전체를 받아서 작업해야 된다는 부분도 경우에 따라서는 단점이 될 수도 있다. 로컬 저장소 사이즈가 그리 크지 않다지만, 기존 형상관리 툴이 원하는 파일 하나만 덜렁 받아서 작업하고 체크인할 수도 있는 것에 비해서는 자리를 더 차지하는 것이 맞다.  
<br/>
### branch 추가 공부
#### branch 생성 및 이동
브랜치는 특정 커밋에 대한 참조(reference)에 지나지 않는다. 이런 사실 때문에 수많은 Git 애찬론자들이 자주 이렇게 말하곤 한다:  
```
브랜치를 서둘러서, 그리고 자주 만드세요
```
브랜치를 많이 만들어도 메모리나 디스크 공간에 부담이 되지 않기 때문에, 여러분의 작업을 커다른 브랜치로 만들기 보다, 작은 단위로 잘게 나누는 것이 좋다.  

브랜치와 커밋을 같이 쓸 때, 어떻게 두 기능이 조화를 이루는지 알아보겠지만, 우선 단순히 브랜치를 __"하나의 커밋과 그 부모 커밋들을 포함하는 작업 내역"__ 이라고 기억하면 된다. [branch 연습하기](https://learngitbranching.js.org/?locale=ko)  

- "git branch 브랜치명"으로 브랜치 생성
- 새 브런치의 변경내역을 기록하려면, 일단 "git checkout 브랜치명"으로 해당 브랜치로 이동한 후 git commit!  <br/> 
#### branch 합치기
두 별도의 브랜치를 합치는 몇가지 방법. 이제부터 배우는 방법으로 브랜치를 따고, 새 기능을 개발 한 다음 합칠 수 있게 될 것이다.  

- git merge

Git의 합치기(merge)는 두 개의 부모(parent)를 가리키는 특별한 커밋을 만들어 낸다. 두개의 부모가 있는 커밋이라는 것은 "한 부모의 모든 작업내역과 나머지 부모의 모든 작업, 그리고 그 두 부모의 모든 부모들의 작업내역을 포함한다"라는 의미가 있다.  
```
예를들어, (c0, c1 - 보라/ c2 - 파랑/ c3 - 빨강)

        c0
        ↑
        c1
    c2 ↗ ↖ c3
   (cat)    (master*)
   
그림 설명) 
여기에 브랜치가 두 개 있다. 각 브랜치에 독립된 커밋이 하나씩 있다. 
그 말은 이 저장소에 지금까지 작업한 내역이 나뉘어 담겨 있다는 얘기다.두 브랜치를 합쳐서(merge) 이 문제를 해결해 볼까?
(\*의 의미는 현재 어느 브랜치에 있는지 알려준다. master*는 master 브랜치에 있다는 것.)

cat 브랜치를 master 브랜치에 합쳐(merge) 보겠다.   

```
`git merge cat`
```
(c0, c1, c2 - 보라/ c3, c4 - 빨강)
        c0
        ↑
        c1
    c2 ↗ ↖ c3
   (cat)    
      ↖   ↗
        c4
     (master*)
```
우선, master가 두 부모가 있는 커밋을 가리키고 있다. 또, 커밋들의 색이 바뀐 것을 눈치 챘나? 이해를 돕기위해 색상으로 구분해 표현했다.  
각 브랜치는 그 브랜치만의 색상으로 그렸다. 브랜치가 합쳐지는 커밋의 경우에는, 그 브랜치들의 색을 조합한 색상으로 표시.  
그런식으로 여기에 cat브랜치 쪽을 제외한 나머지 커밋만 master 브랜치의 색으로 칠해져 있다. 이걸 고쳐보면...
  
master 브랜치에 cat를 합쳐(merge) 본다:

`git checkout cat; git merge master`

```
(c0, c1, c2, c3, c4 - 빨강)
        c0
        ↑
        c1
    c2 ↗ ↖ c3
       
      ↖   ↗
        c4
     (master)
     (cat*)
```
cat가 master의 부모쪽에 있었기 때문에, git이 별다른 일을 할 필요가 없었다; __간단히 cat을 master가 붙어 있는 커밋으로 이동시켰을 뿐.__   
이제 모든 커밋의 색이 같아졌고, 이는 __두 브랜치가 모두 저장소의 모든 작업 내역을 포함하고 있다는 뜻__  
<br/>
### 기타 세부 사항
* 실제 코딩에 사용한 시간 : 아직 코딩 단계는 아니라 실제 학습시간. 3시간 20분.
* 학습에 참고한 사이트 : 
    - 깃 허브란1? <https://nolboo.kim/blog/2013/10/06/github-for-beginner/>  
    - 깃 허브란2?<https://psklog.tistory.com/3>  
<br/><br/>

## 7. 학습 내용에 대한 개인적인 총평
비전공자로서 라피신 과정 때 처음 '깃허브'를 접하게 되었는데, 사실 깃이 뭔지, 깃허브를 왜 쓰는건지 정확한 이유를 모르고 있었다. 과제를 올리기 위한 사용법(add, commit, push 등)만 익혀서 사용하기만 했는데, 이번 본과정에 들어와서 깃허브를 왜 쓰는지 조금 더 심도있게 이해를 하고 싶어졌다. 이해를 할 줄 아는 것과 사용만 할 줄 아는 것은 전혀 다른 문제이기에 이번 과제 내용을 깃허브에 대한 조사로 정했다. 이번 레포트를 작성하면서 나중에 팀원들과 함께 프로젝트를 할 때나 개발을 할 때 더 적극적으로 깃을 활용할 수 있을 것 같다는 생각이 들었고, 본과정에서도 역시 깃을 잘 활용할 예정이다. 내 레포트 중 좋은 정보들은 개인 깃에 업로드를 하려 하는데, 내 개인 깃에 마크다운 문서를 어떻게 작성하는지도 오늘 처음 알게 되었다. __파일명 마지막에 확장자명(.md)를 붙여주면 되는데,__ md는 마크다운 문서라는 의미이다. 알고 보니 정말 간단한 건데 모든 게 처음인 나에겐 다 어렵게 느껴진다.<br/><br/>
## 8. 다음 학습 계획
- 첫 번째 과제인 libft를 살펴보고 필요한 지식들을 선별, 학습한다.  
- 모르는 부분에 대해서는 슬랙이나 동료들을 통해 적극적으로 알아보고, 궁금한 부분은 바로 바로 적어 둔다.  
