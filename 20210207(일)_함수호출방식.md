## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [Call-By-Value](#call-by-value)
    - [Call-By-Value에 의한 swap](#call-by-value에-의한-swap)
    - [Call-By-Reference](#call-by-reference)
    - [Call-By-Reference에 의한 swap](#call-by-reference에-의한-swap)
    - [scanf 함수 호출시 &를 붙이는 이유](#scanf-함수-호출시-를-붙이는-이유)
- [7. 실제 학습 시간 및 참고 사이트](#7-기타-세부-사항)
- [8. 학습 내용에 대한 개인적인 총평](#8-학습-내용에-대한-개인적인-총평)
- [9. 다음 학습 계획](#9-다음-학습-계획)  
<br/> 

## 1. 학습 날짜
* 2021-02-07(일)<br/><br/>
## 2. 학습 시간
* 11:00 ~ 12:00 (자가)
* 14:00 ~ 16:00 (자가)<br/><br/>
## 3. 학습 범위 및 주제
* Call-By-Value와 Call-By-Reference가 무엇인지 알아본다.
* swap을 위해 어떤 호출의 형태를 사용해야 할지 예제를 통해 알아본다.<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* Call-By-Value와 Call-By-Reference의 개념을 정리한다.<br/><br/>
## 6. 상세 학습 내용
## Call-By-Value
- **값에 복사**에 의한 함수의 호출
- **가장 일반적**인 함수 호출 형태
- 여기서 말하는 Call은 **함수 call**을 의미한다. 값의 의한 호출과 참조에 의한 호출 두 가지 방법에 대한 차이점과 이해를 할 필요가 있다.

```
#include <stdio.h>

int add(int a, int b);

int main(void)
{
    int val1 = 10;
    int val2 = 20;
    printf("결과 : %d", add(val1, val2));
    
    return 0;
}

int add(int a, int b)    // val1, val2 값을 복사
{
    return (a+b);
}
```
**add 함수는 값의 의한 호출. 즉 `Call-By-Value`의 형태를 가진다.** val1 과 val2라는 변수의 값을 add라는 함수에 전달하고 있다.  
a라는 변수는 10이 되고, b라는 변수는 20의 값을 가지게 된다. **특징은 값의 의한 복사는 val1과 val2의 값만 단순히 전달되었다.**  
그렇지만 int a, b는 완전히 별개의 값이다.  

<br/><br/>

## Call-By-Value에 의한 swap
- swap 함수 : 변수 a와 b의 값을 바꾸는 기능을 한다.
- a, b는 val1과 val2로부터 값을 받았지만 대상은 전혀 다르다. **a와 b의 값이 서로 바뀌더라도 메인함수에 있는 val1과 val2의 값은 바뀌지 않는다.**  
- 함수를 호출한 사람의 의도는 val1과 val2가 지니고 있는 값을 바꾸고자 했고, 출력을 했을 때 val1의 값은 20, val2의 값은 10이 출력되기를 원했다.  
- 그런데 값이 바뀌지 않은 것은 **단순히 값을 복사해서 매개인자로 받았기 때문에 val1과 val2를 직접적으로 다룰 수 없었던 것이다.**
- 이런 함수의 호출이 `Call-By-Reference`이다.  

<br/><br/>

## Call-By-Reference
- **참조(참조를 가능케 하는 주소 값)를 인자로 전달**하는 형태의 함수 호출
```c
#include <stdio.h>

int main(void)
{
    int val = 10;
    adder(&val);    // 변수 val의 주소 전달
    printf("val : %d", val);
    return 0;
}

void adder(int *pVal)
{
    (*pVal)++;    // 포인터 변수 pVal이 가리키는 변수의 값 1 증가.
}
```
위 코드를 보면 `val`이라는 변수를 메인함수에서 선언하고 10으로 초기화했다. 주소는 임의로 0x10 이라고 가정하자.  
**adder**라는 함수는 매개변수로 `&val`의 주소값을 전달하고, 실제로 adder라는 함수는 0x10 이라는 int 형 변수의 주소값을 받아서 함수를 처리한다.  

여기서 아주 중요한 개념은 **adder라는 함수는 val이라는 변수의 주소값을 알고 있다.**    
`(*pval)++` 이라는 포인터가 가르키는 메모리공간, 즉 0x10번지에서 1만큼 증가시키라는 것이다. 값은 10에서 11로 변경된다.  

adder라는 함수내에서 메인함수에 존재하는 지역변수에 접근했다는 것이다. **그건 함수호출 시 '포인터' 즉 변수의 주소값을 가져왔기에 가능했다.**  

이것이 바로 '참조의 의한 호출'이라는 것이다. (Call-By-Reference)

<br/><br/>

## Call-By-Reference에 의한 swap
- val1과 val2가 메인함수에 선언과 동시에 초기화된 코드가 있다고 하자. 각각 0x10과 0x20이라는 주소값을 지닌다고 가정한다.  
- swap함수를 호출할 때 매개인자에게 **값이 아닌 주소값을 전달**한다. `void swap(int* a, int* b)` 라고 해서 포인터가 선언된 걸 알 수 있다.  
- 포인터연산을 통해 직접적인 접근이 가능하다.
- 누군가가 swap 함수를 호출하면서 swap함수 내에서 메인함수에 정의한 변수를 조작하길 원한다면 **참조에 의한 직접적인 접근을 하라**는 말.

<br/><br/>

## scanf 함수 호출시 &를 붙이는 이유
### case 1
```
int main(void)
{
    int val;
    scanf("%d", &val);
}
```
`scanf("%d", &val)` 이라고 나와있는데 입력받은 값을 val이라는 변수에 저장하고 싶다면 **메모리주소 값**을 알아야한다.  
주소값을 모르면 scanf함수는 val이라는 값에 직접적인 전달이 어렵다는 것이다.  
<br/>

### case 2
```
int main(void)
{
    char str[100];
    printf("문자열 입력 : ");
    scanf("%s", str);
}
```
case2를 보면 scanf 함수에서 엔퍼센트 연산자를 쓰지 않았다.  
예를 들어 길이가 100인 배열을 선언했다. **배열의 주소값은 배열의 이름과 같기 때문에** scanf 함수에 주소값이 들어가지 않았다.  

배열의 주소값을 넘겨야 되는데 사실 배열의 이름이 주소값이다. 그래서 이번에는 `$`연산자 생략한 것이다.

<br/><br/>

---
<br/><br/>

## 7. 기타 세부 사항
* 실제 학습 시간 : 3시간 
* 학습에 참고한 사이트 :
    * [링크](https://funylife.tistory.com/entry/%ED%8F%AC%EC%9D%B8%ED%84%B0%EC%99%80-%ED%95%A8%EC%88%98-3-Call-By-Value-Reference?category=432508) 

<br/>

## 8. 학습 내용에 대한 개인적인 총평
오늘은 기본적인 개념 call-by-value와 call-by-reference에 대해 공부하였다. 기본적인 개념이지만 가장 중요하지 않을까 싶다. 실제로 코드를 짤 때 call-by-reference를 이용해서 값을 변경해야 할 것을 call-by-value로 호출해서 틀리거나 수정했던 경험이 많았다. 무엇보다 c언어의 꽃 포인터 개념이 들어가기 때문에 더 주의깊게 고려해야 할 부분이라고 생각한다. 포인터와 배열의 개념이 아직 명확하게 잡힌 것 같지가 않고, 자주 헷갈려서 조만간 이것들에 대해 상세히 공부를 해보아야 겠다.  
<br/>

## 9. 다음 학습 계획
- strlcpy 함수를 공부하고 구현해본다.  
