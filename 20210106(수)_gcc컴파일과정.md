## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [gcc란?](#gcc란)
    - [컴파일러란?](#컴파일러란)   
    - [gcc 컴파일 과정](#gcc-컴파일-과정)
        - [전처리](#1-전처리-단계)  
        - [컴파일](#2-컴파일-단계)
        - [어셈블](#3-어셈블-단계)
        - [링크](#4-링크-단계)   
        - [기타 : 파일 확장자에 따른 처리방법](#5-파일-확장자에-따른-처리-방법)
    - [gcc 실행하기](#gcc-실행하기)
    - [gcc 옵션](#gcc-옵션)
        - [자주 사용되는 옵션](#자주-사용되는-옵션)
            - [o 옵션](#o-옵션)
            - [E 옵션](#e-옵션)
            - [c 옵션](#c-옵션)
            - [I 옵션](#i-옵션)
    - [알게 된 점](#알게-된-점)
    - [실제 학습 시간 및 참고 사이트](#기타-세부-사항)
- [7. 학습 내용에 대한 개인적인 총평](#7-학습-내용에-대한-개인적인-총평)
- [8. 다음 학습 계획](#8-다음-학습-계획)  
<br/>

## 1. 학습 날짜
* 2021-01-06(수)<br/><br/>
## 2. 학습 시간
* 19:00 ~ 22:00(자가)<br/><br/>
## 3. 학습 범위 및 주제
* 지난 시간 예제 직점 실행해보기
* gcc 컴파일 과정을 학습
* 기본적인 gcc 옵션 정리<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* gcc 컴파일 과정을 이해한다.<br/><br/>
## 6. 상세 학습 내용
## gcc란?
원래 C만을 지원했던 컴파일러로 이름도 "GNU C Compiler"였다.  
나중에 C++, 자바, 포트란, 에이다 등 여러 언어를 컴파일 할 수 있게 되면서,  
현재의 이름 (__GNU Compiler Collection__)으로 변경되었다.  
<br>

## 컴파일러란?
**특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 프로그램**을 말한다.  
쉽게 말해 사람들이 알아볼 수 있는 소스파일을 기계가 알아볼 수 있는 기계어 파일로 번역하는 것이다.  
이 과정을 **컴파일**이라 한다.  

참고 : [위키백과](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC)  
<br>

## gcc 컴파일 과정
- 컴파일 과정 시각화  
<center><img src="https://t1.daumcdn.net/cfile/tistory/99B550485BD0667012"></center>  
<br>

컴파일 과정은 크게 `전처리기, 컴파일러, 어셈블러, 링커`에 의한 4단계로 나눌 수 있다.  

주의깊게 볼 부분은 목적파일을 만들어내는 어셈블러 부분과(**gcc -c \*.c**),  
목적 파일들을 엮어 하나의 실행파일로 만들어주는 링커부분(**gcc -o \*.o**)이다.  
참고로 gcc 사용시 `-v` 스위치를 사용하면, gcc 뒤에서 어떤 프로그램이 어떻게 수행되는지 더욱 자세히 확인할 수 있다.  
<br>
- gcc가 실행시키는 프로그램  

|단계|수행|사용 프로그램|
|:----:|:----:|:----:| 
|전처리|전처리기|cpp|
|컴파일|컴파일러|cc1|
|어셈블리|어셈블|as| 
|링킹|링커|ld|  

<br>

### 1) 전처리 단계 
- cpp 프로그램 사용 -- C PreProcessor  
```
소스 파일(hello.c)에 gcc를 동작시키면 가장 먼저 전처리기인 cpp가 동작한다.
cpp는 소스 파일의 #include와 #define과 같은 #으로 시작되는 전처리기 부분을 처리 한다.

예를 들어서 #include "header.h"라는 코드가 있는 경우,
시스템에서 header.h 파일을 읽어와 해당 소스파일에 그대로 삽입시킨다.
즉, 필요한 헤더 파일을 삽입하고 실행 문장의 매크로를 상수로 변환한다.

전처리가 완료된 소스파일은 파일이름뒤에 .i 가 붙어서 저장되지만 디스크에는 저장되지 않는다.
```
<br> 

### 2) 컴파일 단계 
- cc1 프로그램 사용, c++는 cc1plus, obj-c는 cc1obj 사용  
```
컴파일러가 전처리된 파일(hello.i)로부터 어셈블리어로 된 파일(hello.s)을 생성한다.   
그런데 일반적으로 다음 단계인 어셈블 단계를 바로 실행하므로 hello.s 파일은 디스크에 저장되지 않는다.

전처리 단계에서 생성된 file.i 파일을 읽어와 어셈블리 언어(pushq, addl등의 명령으로 이루어진 기계어)로
변환하여 .s 파일을 생성한다. c가 아닌 다른 언어라도 컴파일 단계에서 기계어로 변환되기 때문에,
다음 단계인 어셈블 단계에서는 사용자가 어떤 고수준 언어를 사용했는지 걱정할 필요가 없다.
```
<br>

### 3) 어셈블 단계
- as 프로그램 사용
```
어셈블리어로 된 파일(hello.s)을 기계가 직접 이해할 수 있는 기계어로 된 오브젝트 파일(hello.o)로 변환.

hello.s의 내용을 더욱 쪼개서 instruction 단위로 만들고,
이것을 모아 재배치 가능한 목적프로그램(relocatable object program)의 단위로 묶어 .o 파일을 만든다.
각각의 object 파일은 번역단위(translation unit)를 바탕으로 작성이 되는데, 
번역단위란, 컴파일를 통해 하나의 목적파일을 만드는 바탕이 되는 소스코드를 말하며,
전처리기를 거친(# 지시자등이 모두 처리된) 하나의 c 파일이라고 생각할 수 있다.

또한 재배치 가능하다는 의미는 링커를 통해 다른 목적파일들과 결합이 가능하다는 것을 의미한다. 
이러한 특성으로, 프로그램 소스코드의 일부가 변경되었을 때 전체 소스에 대한 컴파일을 새로 수행하는 것 대신,
해당 목적파일만 생성하고 교체하면 되기 때문에 컴파일의 효율성이 높아진다. 

이 단계부터는 사람이 읽을 수 없는 내용으로 파일이 만들어진다. (binary 파일) 
```
<br>

### 4) 링크 단계
- ld 프로그램 사용  
```
오브젝트 파일(.o)은 printf, scanf와 같은 라이브러리 함수에 해당하는 코드가 없기 때문에 실행될 수 없다.
또한 여러 파일로 이루어진 프로그램의 경우에도 파일 간에 연결이 이루어지지 않아 실행될 수 없는데,
이러한 라이브러리 함수와 오브젝트파일들을 연결해 실행 파일을 생성하는 단계가 링크 단계이다.

많은 프로그램들은 외부의 라이브러리를 참조한다. 대표적으로 화면에 글씨를 출력해주는 printf 함수가 있으며
이는 표준 C 라이브러리에 포함되어 printf.o 목적 파일형태로 대부분의 컴파일러와 함께 제공된다. 
hello.o 파일과 printf.o 파일을 결합해야 프로그램이 정상 작동하는데, 이러한 결합은 링커 프로그램을 통해 이루어진다.
이 단계가 완료되면 그 결과로 실행파일이 생성되어 사용자에게 배포될 수 있다.
```  
<br>

### 5) 파일 확장자에 따른 처리 방법

gcc는 파일 확장자에 따라 다음과 같이 처리 방법을 달리하는데,  
한 가지만 설명하면 확장자가 .c인 경우 gcc로 전처리기, 컴파일, 어셈블, 링크 과정을 거쳐야 실행 파일이 완성된다.

|확장자|종류|처리방법|
|:---:|:---:|:----:|
|.c|C 소스 파일| gcc로 전처리, 컴파일, 어셈블, 링크|
|.C .CC|C++ 소스 파일|g++로 전처리, 컴파일, 어셈블, 링크|
|.i|전처리된 C 파일|gcc로 컴파일, 어셈블, 링크|
|.ii|전처리된 C++ 파일|g++로 컴파일, 어셈블, 링크|
|.s|어셈블리어로 된 파일|어셈블, 링크|
|.S|어셈블리어로 된 파일|전처리, 어셈블, 링크|
|.o|오브젝트 파일|링크|
|.a .so|컴파일된 라이브러리 파일|링크|  

그리고 컴파일을 할 때는 각 단계별로 옵션을 사용해 얼마나 진행되었는지 그 상황을 볼 수 있게 수동으로 제어할 수 있는데,  
이에 대한 자세한 내용은 gcc 옵션에서 다룬다.  
<br><br>  

---
<br>

## gcc 실행하기
- gcc를 이용하여 컴파일 하는 방법
```
$ gcc 소스파일이름
```  
gcc를 이용해 컴파일에 성공하면 `a.out`이라는 파일이 생성된 것을 확인할 수 있는데,  
여기서 그냥 명령어로 a.out을 입력하면 명령어를 발견할 수 없다는 오류 메시지가 나온다.  

이는 a.out가 저장된 디렉토리를 path로 설정하지 않았기 때문이다.  
path로 설정되지 않는 디렉토리에 있는 명령어는 디렉토리 위치를 지정해주지 않는 한 실행되지 않는다.  

그러므로 a.out를 실행하려면 다음과 같이 해야 한다.
```
$ ./a.out
```  
즉, 프로그램 이름 앞에 디렉토리 위치 정보인 ./를 추가해야 현재 디렉토리에 있는 명령어가 실행되는데,  
여기서 마침표(.)는 현재 디렉토리를 의미하고, 슬래시(/)는 디렉토리를 구분하는 문자다.  
<br>

---
<br>

## gcc 옵션
|옵션|의미|
|:---:|:---|
|-E|전처리를 실행하고 컴파일을 중단하게 한다. 전처리 과정의 결과를 화면에 보임으로써, 전처리과정 중 발생한 오류 검증.|
| __-c__ |소스 파일을 컴파일만 하고 링크를 수행하지 않으며, 오브젝트 파일을 생성한다.|
| __-o__ |바이너리 형식의 출력 파일 이름을 지정하는데, 지정하지 않으면 a.out라는 기본 이름이 적용된다.|
|-I|헤더 파일을 검색하는 디렉토리 목록을 추가한다.|
|-L|라이브러리 파일을 검색하는 디렉토리 목록을 추가한다.|
|-l|라이브러리 파일을 컴파일 시 링크한다.|
|-g|바이너리 파일에 표준 디버깅 정보를 포함시킨다.|
|-ggdb|바이너리 파일에 GNU 디버거인 gdb만이 이해할 수 있는 많은 디버깅 정보를 포함시킨다.|
|-O|컴파일 코드를 최적화 시킨다.|
|-ON|최적화 N 단계를 지정한다. N=0일 경우 아무런 최적화를 수행치 않음.|
|-static|정적 라이브러리에 링크한다. 속도는 빠르지만 파일 사이즈 커짐.|
|-ansi|표준과 충돌하는 GNU 확장안을 취소하며, ANSI/ISO C 표준|
| __-Wall__ |모든 오류와 경고를 출력|
|-W|합법적이지만 모호한 코딩에 대해서 경고|
|-Wall -W|모든 경고 메시지 출력. 아주 사소한 모호성에 대해서도 경고가 발생.|
| __-Werror__ |모든 경고를 오류로 취급하여 컴파일 중단.|
|-w|모든 경고 메시지 제거|
|-MM|make 호환의 의존성 목록을 출력한다.|
| __-v__ |컴파일의 각 단계에서 사용되는 명령어를 보여준다.|  

<br>

### 자주 사용되는 옵션
#### **-o 옵션**  
C 소스 코드를 컴파일 할 때 생성되는 출력 파일 이름을 지정하는 옵션.
```
기본형 :  <gcc -o 출력파일이름 소스파일이름>  or  <gcc 소스파일이름 -o 출력파일이름>
```
$ gcc -o file file.c 또는 $ gcc file.c -o file 을 입력한다.  
그럼 출력파일이 file이라는 이름으로 생성되고, 이를 실행하려면 $ ./file 이라고 실행하면 된다.  

`-o 옵션을 생략`하고 컴파일을 하면 실행 파일 이름은 `a.out`가 되는데, 이 경우 **두 가지 다른 소스를  
차례로 컴파일할 때 먼저 생성된 실행 파일 a.out를 나중에 생성된 a.out가 경고없이 덮어쓰므로 주의!**  
<br/>
#### **-E 옵션**  
컴파일의 첫 단계인 전처리까지만 실행한 결과를 화면에 출력한다.
```
기본형 : gcc -E 소스파일이름
```
$ gcc -E file.c로 컴파일을 하면 매우 방대한 내용이 소스파일 위에 붙는 것을 확인할 수 있다.   

이처럼 `-E` 옵션만 주면 **전처리된 결과가 화면에만 출력되고 파일로 저장되지는 않는다.**    
파일을 저장하려면 `-o` 옵션을 함께 주어야 하고, 그러면 file.i라는 전처리된 파일이 디스크에 저장된다.  
```
$ gcc -E file.c -o file.i
```
<br/>

#### **-c 옵션**    
전처리, 컴파일, 어셈블까지 실행하며 **오브젝트(.o) 파일을 생성한다.**
```
기본형 : gcc -c 소스파일이름
```  
file.c를 `-c` 옵션을 사용해 컴파일 하면 file.o라는 오브젝트 파일이 생성된다.  
즉, -c 옵션을 주어 file.c을 컴파일하면 오브젝트 파일 file.o가 된다.  
<br/>
```
gcc -c file.c
```
그리고 이 **오브젝트 파일을 이용해 실행 파일을 생성**하려면 다음과 같이 gcc 이용.
```
gcc file.o
```
그럼 a.out이라는 기본 출력 파일이 생성된다. 여기서 file이라는 이름의 실행파일을 생성하려면
```
gcc file.o -o file
```
<br>
-c 옵션은 하나의 프로그램을 여러 파일로 분리해 작성한 다음, 함께 컴파일하는 **분리 컴파일 시** 많이 사용.  

예를 들어, main.c와 hi.c 두 개의 소스로 구성된 프로그램을 살펴보자.  
```c
// main.c

extern void hi();

main()
{
    hi();
}
```
```
// hi.c
#include <stdio.h>

void hi()
{
    printf("Hi\n");
}
```
이 둘을 함께 컴파일 하는 방법은 다음과 같으며, 이를 **분리 컴파일** 이라 한다.
```
$ gcc -o test main.c hi.c
$ ./test
Hi
```
만약 다음과 같이 파일별로 컴파일 하면 컴파일 오류 발생하는데, main.c 파일에 대한 오류는  
호출하는 함수 hi라는 함수가 정의되지 않았기 때문이고, hi.c 파일에대한 오류는 main 함수가 없기 때문.  
```
$ gcc main.c -o test
$ gcc -o hi.c hi.c
```
그러나 다음과 같이 각 파일별로 오브젝트 파일을 만들고 나중에 링크하는 것은 가능하다.  
```
$ gcc -c main.c
$ gcc -c hi.c
$ gcc main.o hi.o -o test
```
이런식으로 분리 컴파일을 하게 되면,  
만일 hi.c 파일이 수정되면 **main.c와 hi.c를 모두 컴파일 할 필요 없이**  
hi.c 파일에 대한 오브젝트 파일만을 생성하고 링크하면 원하는 실행 파일이 생성된다.  
```
# hi.c를 수정하고 나서 다시 컴파일

$ gcc -c hi.c
$ gcc main.o hi.o -o test
```  
<br>

#### **-I 옵션**  
-I 옵션은 C 소스가 표준 디렉토리가 아닌 위치에 있는 헤더 파일을 가질 때, 그 디렉토리 위치를 지정해준다.  
```
gcc 소스파일이름 - I 디렉토리이름
```
먼저 myheader.h 파일이 age.c 파일이 있는 디렉토리의 하위 디렉토리인 mydir에 있다고 하자.    
```
// age.c

#include <stdio.h>
#include "myheader.h"

int main()
{
printf("%d\n", AGE);
}
```
```
// myheader.h

#define AGE 20
```
age.c 파일을 컴파일하면(gcc age.c) myheader.h 파일이 없다는 메시지의 컴파일 오류 발생한다.  
myheader.h 파일이 표준 디렉토리에 없기 때문에 오류가 발생하는 것이다. 이와 같이, 표준 디렉토리가 아닌  
디렉토리에 있는 헤더 파일을 이용하려면 `-I` 옵션으로 디렉토리 위치를 지정해야 한다.  

즉, myheader.h 파일이 있는 mydir 디렉토리를 다음과 같이 지정해 컴파일하면 성공한다.  
```
$ gcc age.c -I mydir
$ ./a.out
20
```
<br>

## 알게 된 점
**지난 보고서의 예제**를 실제 실행해본 후 알게 된 점
* __-c__ 옵션을 안 주고 gcc만 하면 오브젝트 파일은 생성이 안되고 실행 파일만 만들어 진다.  
* 지난 보고서 예제에서 Makefile을 만들어 놓고, object가 되는 c파일 중 하나,  
예를 들면 main.c를 수정하고 다시 make 하면 
main.c에 대한 명령만 수행된 후(main.o 파일 새로 저장) 실행 파일 diary_exe가 다시 만들어 진다.<br/><br/> 
## 기타 세부 사항
* 실제 학습 시간 : 3시간
* 학습에 참고한 사이트 :   
    * [gcc 컴파일러](https://frontjang.info/entry/GCC-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EC%97%90-%EB%8C%80%ED%95%B4-1-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EC%9D%98-4%EA%B0%80%EC%A7%80-%EB%8B%A8%EA%B3%84)  
    * gcc 컴파일 과정 및 옵션들 [링크1](https://kimdora.tistory.com/entry/GCC-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95) [링크2](https://seamless.tistory.com/2)    
<br/>

## 7. 학습 내용에 대한 개인적인 총평
지난 시간에 make와 makefile의 기본적인 개념을 공부하던 중 컴파일 과정에 대해 궁금증이 생겨서, 이번 보고서에 정리하게 되었다. 라피신 과정 땐, 기계적으로 "c파일을 컴파일 할 때 gcc를 이용한다."만 암기했지, 어떤 과정을 통해 c파일을 실행시키는 것인지 몰랐다. 이번 기회에 컴파일의 의미와 gcc의 컴파일 과정에 대해 자세히 알아보고 적용해 볼 수 있어서 의미있었다. 공부하다 보니 왜 굳이 오브젝트 파일을 만들어 사용하는지도 궁금해졌는데, 이 내용도 조만간 정리해봐야겠다.  
<br/>

## 8. 다음 학습 계획
- gcc로 정적 라이브러리를 만드는 방법을 학습한다. [링크](https://velog.io/@hidaehyunlee/GCC%EB%A1%9C-%EC%A0%95%EC%A0%81-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%8C%8C%EC%9D%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0) 
- object 파일을 만들어 사용하는 이유에 대해 알아본다. [링크](http://ith.kr/chair/cpp/cpp103.html)
