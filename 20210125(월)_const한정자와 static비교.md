## 목차
- [1. 학습 날짜](#1-학습-날짜)
- [2. 학습 시간](#2-학습-시간)
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)
- [4. 동료 학습 방법](#4-동료-학습-방법)
- [5. 학습 목표](#5-학습-목표)
- [6. 상세 학습 내용](#6-상세-학습-내용)
    - [과제 궁금증](#-과제-궁금한-점)
    - [한정자란?](#-한정자)
    - [const](#-const)
        - [1) 자료형에 붙는 const](#1-자료형에-붙는-const)
        - [2) 변수 이름에 붙는 const](#2-변수-이름에-붙는-const)
        - [3) 변수와 자료형에 모두 붙는 const](#3-변수와-자료형에-모두-붙는-const) 
        - [4) 함수 선언에서의 const의 의미](#4-함수-선언에서의-const의-의미)
    - [const와 static 차이점](#-const와-static-차이점)    
    - [전역변수와 정적변수 차이점](#-전역변수와-정적변수-차이점)  
- [7. 실제 학습 시간 및 참고 사이트](#7-기타-세부-사항)
- [8. 학습 내용에 대한 개인적인 총평](#8-학습-내용에-대한-개인적인-총평)
- [9. 다음 학습 계획](#9-다음-학습-계획)  
<br/> 

## 1. 학습 날짜
* 2021-01-25(월)<br/><br/>
## 2. 학습 시간
* 12:00 ~ 15:00 (자가)<br/><br/>
## 3. 학습 범위 및 주제
* 한정자에 대해서 학습한다.
* const 한정자를 학습한다.
* const와 static의 차이점을 구분할 줄 안다.<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* 한정자의 개념을 정리하여 과제 해결에 이용할 수 있다.<br/><br/>
## 6. 상세 학습 내용
## - 과제 궁금한 점
과제를 하려고 보니 아래와 같은 주의사항이 있었다.
```
Some of the functions’ prototypes you have to re-code use the
"restrict" qualifier. This keyword is part of the c99 standard.
It is therefore forbidden to include it in your prototypes and to
compile it with the flag -std=c99.
```
restrict 한정자란 뭘까? C99은 뭘까?  
<br/>

## - 한정자
**변수에 특성을 부여하는(혹은 기능상 제한을 가하는) 키워드**들로 `const / volatile / restrict` 가 있다.  
<br/>

## - const
변수 선언에서 `const`키워드는 **해당 변수를 대입/증가/감소 연산으로 값을 변경할 수 없는 변수로 만든다. 따라서 선언시에만 값 초기화가 가능하다.**  
const 키워드를 일반 변수 선언에 사용할 때에는 크게 걱정할 것은 없지만, 포인트 변수 선언시에는 위치에 따라 그 의미가 달라지므로 주의해야 한다.    
즉, 포인터 '주소' 자체를 const로 만드는 것과, 포인터가 가리키는 '값'을 const로 만드는 상황을 구분해야 한다.  
<br/>

### 1) 자료형에 붙는 const
`ptr`은 항상 상수로 유지해야 하는 int형 '값'을 가리키는 포인터 변수이다. ptr이 가리키는 '값'이 상수라는 것!!  
따라서 `ptr`이 가리키는 주소는 변경될 수 있다. 즉, `ptr`이 다른 `const` 값을 가리키도록 ptr의 주소를 변경할 수는 있다.  

```c
const int *ptr;
```

> ptr을 통해서 값을 변경할 수 없다. **`(*ptr)++` 불가능** (참조만 가능)  
> ptr을 통해서 할 수 없다는거지 값 자체는 변경할 수 있다.
  
> `const int*` 와 `int const*` 는 같은 표현  
> 데이터형 이름과 `*` 사이에 `const`를 넣는 것은 그 포인터를 사용하여 그것이 가리키는 값을 변경할 수 없다는 것을 의미한다.  
> 즉, **`const`를 `*` 왼쪽 어딘가에 넣으면 그 '값'을 상수로 만들고 `*` 의 오른쪽에 넣으면 그 포인터 자체('주소')를 상수로 만든다.**

<br/><br/>

### 2) 변수 이름에 붙는 const  
포인터 ptr의 값(주소)을 변경할 수 없다. 즉 ptr은 항상 같은 주소를 가리킨다.    
그러나 ptr이 가리키는 값은 변경할 수 있다. 포인터 변수 ptr의 주소를 상수화 시킨다는 의미이다.  
**`(*ptr)++` 가능**
```c
int* const ptr = &num;
```
> 포인터 변수 ptr을 상수화 시킨다.  
> ptr에 저장된 값 변경 불가 = **num만을 가르킴**  
> `mutable` : const 함수 내에서의 값의 변경을 예외적으로 허용하게 해 줌.  

<br/><br/>

### 3) 변수와 자료형에 모두 붙는 const
```c
const float * const ptr;
```
ptr은 항상 같은 주소를 가리키고 그 위치에 저장된 값도 변경할 수 없다.  

<br/><br/>

### 4) 함수 선언에서의 const의 의미
- 파라미터로 넘어간 변수의 값을 변경할 수 없다.
- 리턴된 '값'을 변경할 수 없다.
- C++에 추가된 클래스 개념을 위해 클래스 멤버변수 값을 변경할 수 없다.  

```
void display(const int array[])
```
> display 함수는 호출함수에 있는 '데이터'를 변경할 수 없게 된다.  

<br/>

```
const int* f()
{
    return (&i);
}
```
> `f()`가 반환하는 값은 반드시 `const int*` 변수에 대입되어야 한다.  
> 이것은 `f()`의 반환 값이 추후에라도 변경되는 것을 방지한다.  

<br/>

```
void CTest::Print() const;
```
> 멤버함수의 괄호 뒤에 const를 붙이면 해당 함수는 클래스(CTest) 내의 어떠한 멤버변수도 값을 변경시킬 수 없다.  
> (포인터형을 리턴할 수도 없다.)

<br/><br/>

### 5) 그 외 const의 활용
- 프로그램에서 사용할 상수를 선언할 때, **전역변수를 사용하다보면 실수로 데이터가 변경될 수 있으므로 이를 방지하기위해 `const`를 사용하기도 한다.**  
- 상수를 선언하는데에는 두가지 방법이 있는데, 1) 전역변수 형태로 `const double PI=3.14;` 로 하고 외부 파일에서 `extern const double PI;`를 사용할 수도 있고,  
아니면 2) 헤더 파일에 `static const double PI = 3.14;`로 선언하고 c 파일에서 헤더파일을 include하여 사용할 수 있다.  
헤더파일 방식으로 상수변수를 선언했을 때의 장점은 한 파일에 전역변수를 선언하고 나머지 파일들에 extern으로 참조선언을 추가로 해줄 필요가 없이  
그저 모든 파일들이 동일한 헤더파일을 include하면 된다는 것이다. 대신 단점으로 데이터가 중복되어 저장된다는 점이 있다.  


> 전역변수의 형태로 헤더파일에 상수를 정의할때, 만약 `static`을 사용하지않은 채(즉, `double P`I) c파일에서 include하는 경우,  
> 동일한 변수의 정의 선언이 각 파일에 들어가는 결과를 가져온다. 즉, 각 변수들이 '외부연계 정적변수'로 사용되어 별개의 데이터 복사본이  
> 각각의 파일에 하나씩 제공된다. 따라서 이름이 동일하더라도 전혀 다른 변수로 인식되고 사용되기 때문에 파일간의 커뮤니케이션에 그 데이터를  
> 사용하면 제대로 동작하지 않을 수 있다. 그러나 `const`라도 사용하게 되면(즉, `const double PI`) 해당 변수의 값이 변하지 않으므로  
> 조금 더 안정적인 실행을 기대할 수 있다(물론 static const 둘다 사용하는 것이 최선이다). 

<br/>

---
<br/>

## - const와 static 차이점
### 1) const
- 해당 변수를 초기화 한 이후에는 절대 바꾸지 못하도록 선언하는 것.
- 초기화 되고 나면 그 이후에는 절대 값을 바꿀 수 없다.

<br/>

### 2) static
- 선언을 하게 되면 그 위치에 상관없이 프로그램의 시작부터 끝까지 메모리에 할당 되어 있으면서 그 값을 마음대로 바꿀 수 있는 것.  
- 위치에 대해서는 전역변수든 지역변수든 상관 없다.  
- 함수 또는 파일 내에서 값을 보존할 필요가 있을 때

> - 블럭 안에서만 유효한 값을 가지지만 자동변수와 같이 없어지지 않고, 블럭으로 돌아왔을 때 이전 값 다시 이용 가능  
> - 초기화 생략시 0으로 자동 초기화  
> - 선언된 위치에 따라 다음과 같이 구분 됨.  
>     - 내부정적변수 : 함수 내부에서 선언되며, 함수 내부에서만 사용이 가능. 하지만 프로그램이 실행되는 동안 존재.
>     - 외부정적변수 : 함수 외부에서 선언되며, 다른 소스 파일에서는 참조할 수 없다.

<br/>

---
<br/>

## - 전역변수와 정적변수 차이점
함수안에 선언된 변수는 그 함수를 빠져 나가면 사라진다. 할당되었던 메모리는 해제되고 저장되어 있던 값도 사라진다.  
이러한 특성 때문에 **자동변수(auto variable)** 이라고 부르기도 한다. 그 함수 내에서만 유효하다고 해서 **지역변수**라고 부르기도 한다.  
따라서 그 함수로 들어올 때 마다 변수가 다시 메모리 할당된다.

그래서 함수간 또는 파일간에 변수 값을 공유하고자 할 때는 전역변수(global variable) 또는 정적변수(static variable)를 사용하는데  
이 두 변수간의 차이를 정확히 이해를 하고 사용해야 한다.  

전역변수와 정적변수는 lifetime은 동일하다. 즉, 해당 프로그램이 죽을 때까지 한번 할당된 변수 메모리와 값은 유지된다는 점이다. 반면에 scope는 서로 다르다.  
전역변수는 해당 프로그램(실행파일 기준)의 어느 함수, 어느 파일에서도 접근이 가능한 반면 **정적변수는 변수가 선언된 파일이나 함수내에서만 접근이 가능하다.**  

scope에 대한 예를 들면  a 파일에 선언되어 있는 static 변수는 a파일에서는 어느곳에서나 접근이 가능하지만 b파일 에서는 읽을 수가 없다. (file scope)  
동일 파일 속에서도  a() 함수 속에서 선언된 static 변수는 a()의 어느곳에서도 접근할 수 있지만 b() 함수 에서는 접근할 수 없는 것이다. (function scope)    반면에 global 변수는 프로그램내의  어느 파일, 어느 함수에서도 읽을 수 있다.  

lifetime 에 대하여 고찰해 보면 한번 선언된 전역변수와 정적변수의 값은 프로그램(프로세스)가 죽을 때까지 계속 유지된다.  
따라서 미들웨어에 의해 프로세스가 통제되는 프로젝트의 경우 프로세스가 죽지 않고 항상 살아있기 때문에 매번 거래가 시작될 때 반드시 변수를 초기화.  
초기화를 빼먹을 경우 이전 거래에서 사용했던 변수 값들이 그대로 보존되어 있기 때문에 잘못된 결과를 초래할 수 있기 때문이다.

이러한 개념은 extern 함수와 static 함수에도 똑같이 적용된다. static 함수는 해당 파일 내에서만 호출될 수 있다. 그러나 extern 함수는 다른 파일 속에서도 호출될 수 있는 것이다. 보통 extern 함수 앞에는 extern 이란 말을 생략하기도 한다. 따라서 static 이 붙지 않은 것은 extern 함수라고 간주하면 될 것이다. 


출처: <https://pangate.com/541>  
<br/><br/>

## 7. 기타 세부 사항
* 실제 학습 시간 : 3시간 
* 학습에 참고한 사이트 :
    * [한정자](https://heurinbada.tistory.com/25)
    * [한정자 자세히](https://frontjang.info/entry/C%EC%9D%98-%EA%B8%B0%EC%96%B5%EB%B6%80%EB%A5%98Storage-Class%EC%99%80-%EB%B3%80%EC%88%98-3-%ED%83%80%EC%9E%85-%ED%95%9C%EC%A0%95%EC%9E%90Type-Qualifier)
    * [static / const 차이점](https://snowting-mj.tistory.com/59)

<br/>

## 8. 학습 내용에 대한 개인적인 총평
오늘은 const라는 새로운 한정자에 대해 공부해봤는데, static도 '정적'이라는 의미 때문에 const와 비슷한게 아닌가 순간 착각했었다. 그런데 const와 static은 아예 개념 자체가 다른게 const는 값을 못바꾸게 하는 거고, static은 값을 바꿀 수 있다. 그리고 static 변수는 전역변수처럼 프로그램이 끝날 때까지 없어지지 않는데, 이 둘의 차이점이 명확히 이해가 안가서 [사이트](https://chfhrqnfrhc.tistory.com/entry/%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%99%80-%EC%A0%84%EC%A0%81%EB%B3%80%EC%88%98)를 참고했다. static으로 선언을 하면 다른 파일에서는 접근 불가하다! 바로 전 보고서에 정적변수 개념을 정리했었는데, 자꾸 헷갈린다.   
<br/>

## 9. 다음 학습 계획
- restric 한정자까지 알아보려 했는데 찾다보니 내용이 길어져서 다음 보고서에 restric한정자를 정리하려 한다.
