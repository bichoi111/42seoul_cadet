## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [포인터 대상의 const 선언](#1-포인터-대상의-const-선언)
        - [포인터 변수가 참조하는 대상의 변경을 허용하지 않는 const 선언](#포인터-변수가-참조하는-대상의-변경-을-허용하지-않는-const-선언)
        - [포인터 변수의 상수화](#포인터-변수의-상수화)
        - [두 가지 형태의 const 선언 동시에 사용하기](#두-가지-형태의-const-선언-동시에-사용하기)
        - [const 선언이 갖는 의미](#const-선언이-갖는-의미)
    - [널 포인터](#2-널-포인터)
        - [잘못된 포인터의 사용](#잘못된-포인터의-사용)
        - [포인터 초기화](#포인터-초기화)
    - [void 포인터](#3-void-포인터)
        - [함수 포인터의 이해](#함수-포인터의-이해)
        - ['형(Type)'이 존재하지 않는 void 포인터](#형-type-이-존재하지-않는-void-포인터) 
- [7. 실제 학습 시간 및 참고 사이트](#7-기타-세부-사항)
- [8. 학습 내용에 대한 개인적인 총평](#8-학습-내용에-대한-개인적인-총평)
- [9. 다음 학습 계획](#9-다음-학습-계획)  
<br/> 

## 1. 학습 날짜
* 2021-02-17(수)<br/><br/>
## 2. 학습 시간
* 18:00 ~ 22:00 (자가)<br/><br/>
## 3. 학습 범위 및 주제
* 포인터를 대상으로 하는 const 선언의 쓰임 알아보기
* 널 포인터 학습
* void 포인터 학습<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* const 선언에 대해 완벽히 익히고, 널 포인터와 void 포인터에 대해 학습한다. <br/><br/>
## 6. 상세 학습 내용
## 1) 포인터 대상의 const 선언
### 포인터 변수가 *참조하는 대상의 변경*을 허용하지 않는 const 선언
아래의 코드에서 보이는 바와 같이 포인터 변수 `ptr`을 대상으로도 `const`선언을 할 수 있다.  
```c
int main(void)
{
    int num = 20;
    const int *ptr = &num;
    *ptr = 30;  // 컴파일 에러
    num = 40;   // 컴파일 성공
}
```
위와 같이 맨 앞부분에 const 선언이 되면,  
**포인터 변수 ptr을 이용해서 ptr이 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않겠다**는 의미이다.   
때문에 `*ptr = 30;`에서 컴파일 에러가 발생한다. 그렇다고 해서 포인터 변수 **ptr이 가리키는 변수 `num`이 상수화되는 것은 아니다.**  
따라서 `num = 40`과 같이 num에 저장된 값을 변경하는 것은 허용된다.  

> 이렇듯 위의 const 선언은 **값을 변경하는 방법에 제한을 두는 것**이지 무엇인가를 상수로 만드는 선언은 아니다.  

<br/><br/>

### 포인터 변수의 상수화
- 포인터 변수의 이름 앞에 `const` 선언이 올 경우
```
int * const ptr = &num;
```
이렇게 되면 **포인터 변수 `ptr`은 상수가 된다.**  
이 의미는 **한번 주소값이 저장되면 그 값의 변경이 불가능**하다는 뜻이며, 이는 한번 가리키기 시작한 변수를 끝까지 가리켜야 한다.  
<br/>

```
int main(void)
{
    int num1 = 20;
    int num2 = 30;
    int *const ptr = &num1;
    ptr = &num2;  // 컴파일 에러
    *ptr = 40     // 컴파일 성공!
}
```
위의 코드를 보면, 상수화된 포인터 변수 `ptr`이 `num1`을 가리키고 있다.  
그런데 그 다음 행에서, 가리키는 대상을 num2로 바꾸기 위한 연산을 진행하고 있다.  
하지만 **ptr은 상수**이기 때문에 이 부분에서 컴파일 에러가 발생한다.  

물론 ptr이 상수일 뿐이니, `*ptr = 40`과 같이 **ptr이 가리키는 대상에 저정된 값을 변경하는 연산은  문제가 되지 않는다.**  
<br/><br/>

### 두 가지 형태의 const 선언 동시에 사용하기
지금까지 포인터 변수를 대상으로 하는 두가지 형태의 const 연산에 대해 설명했는데,  
다음과 같이 하나의 포인터 변수를 대상으로 이 두가지 형태의 const 선언을 동시에 할 수도 있다.  
```
const int * const ptr = &num;
```
이렇게 선언이 되면 맨 앞의 `const` 선언으로 인해서 다음의 연산이 불가능해지고,
```
*ptr = 20;  // 컴파일 에러
```
포인터 변수 ptr 앞의 `const` 선언으로 인해서 다음의 연산도 동시에 불가능해진다.  
```
ptr = &age;
```
<br/><br/>

### const 선언이 갖는 의미
const 선언이 특별한 기능을 제공하는 것은 아니기 때문에 그 중요성을 인식하지 못하는 경우가 많다.  
반면 if 문이나 for문은 제공하는 고유의 기능이 있기 때문에 중요하게 여긴다.  

사실 `const`는 처음부터 C언어에 존재하던 키워드는 아니다. `const`는 C++에만 존재하던 키워드였는데,  
C언어의 표준을 재정립하는 과정에서 C언어의 일부가 된 것이다. 그만큼 `const` 선언은 중요하고 유용하다는 것이다.  
**const 선언을 많이 하면 그만큼 프로그램 코드의 안전성은 높아진다.** 이와 관련해서 다음 코드를 보자.  
```
int main(void)
{
    double PI = 3.1415;
    double rad;
    PI = 3.07;    // 실수로 잘못 삽입된 문장, 컴파일 시 발견 안됨.
    scanf("%lf",&rad);
    printf("circle area %f \n", rad*rad*PI);
    return 0;
}
```
위의 main 함수에서는 원의 넓이를 계산하여 출력한다.  
그런데 **원주율에 해당하는 값이 저장된 변수 PI의 값을 변경하는 실수**를 범하고 있다.  
물론 이 프로그램을 작성한 사람도 PI에 저장된 값을 변경하면 안된다는 것은 알고 있을 것이다.  
그럼에도 불구하고 이런 실수가 발생하였다. 하지만 이보다 더 큰 문제는 **컴파일러가 이러한 문제점을 발견하지 못한다는데 있다.**  

이것이 왜 큰 문제인가? 컴파일러가 발견하지 못하는 오류의 상황은 쉽게 발견되지 않기 때문이다.  
혹 실행결과를 통해서 문제가 있다고 판단을 했어도 무엇이 문제인지 쉽게 찾아낼 수가 없다.  

예를 들어서 약 8천 라인 정도되는 프로그램을 작성하고 컴파일까지 완료한 상태에서 실행을 해보니 그 결과가 조금 이상하다면  
어디서부터 시작해서 문제를 찾아낼 것인가? 바로 이러한 문제점 때문에 현명한 프로그래머는 다음과 같이 코드를 작성한다.  
<br/>
```
int main(void)
{
    const double PI = 3.1415;
    double rad;
    PI = 3.07;    // 컴파일 시 발견되는 오류상황
    scanf("%lf", &rad);
    printf("circle area %f \n", rad*rad*PI);
    return 0;
}
```
앞서 보인 코드와의 유일한 차이점은 변수 PI를 대상으로 하는 `const` 선언이다. 하지만 이로 인해서 **PI에 대한 안전성은 확보**가 되었다.  
PI에 저장된 값이 변경되는 오류를 실행파일이 생성되기 전에 막을 수 있으니, 그만큼 코드의 안전성이 높아진 것이다.  
이렇듯 `const` 선언 하나에는 매우 큰 가치를 부여할 수 있다.  
<br/><br/>

---
<br/><br/>

## 2) 널 포인터
### 잘못된 포인터의 사용
포인터 변수에는 메모리의 주소 값이 저장되고, 이를 이용해서 해당 메모리 공간에 접근도 가능하기 때문에 주의를 해야한다.  
#### - 잘못 사용된 예 1
```
int main(void)
{
    int *ptr;  // 포인터 변수 ptr은 쓰레기 값으로 초기화 됨.
    *ptr = 200;
    ...
}
```
위와 같이 **포인터 변수를 선언만하고 초기화하지 않으면, 포인터 변수는 쓰레기값으로 초기화 된다.**  
즉 어디를 가리킬지 모르게 된다. 때문에 이러한 상태에서 `*`연산을 통해 200을 저장하는 것은 치명적인 결과로 이어질 수 있다.  
ptr이 가리키는 위치가 어디인 줄 알고 값을 저장하는 것인가! 

**만약에 ptr이 가리키는 메모리 공간이 매우 중요한 위치였다면, 이는 시스템 전체에 심각한 문제**를 일으킬 수도 있는 상황이다.  
다행히 요즘의 운영체제는 이렇게 잘못된 메모리 접근의 시도가 있을 때, 이를 감지하고 해당 프로그램을 중지시켜서 잘못된 메모리의 접근을 미연에 방지한다.  
그런데 프로그램을 중지시킨 이후에 전달하는 메시지의 형태는 운영체제 별로 차이가 있으니 직접 확인해보기 바란다.  
<br/>

#### - 잘못 사용된 예 2
```
int main(void)
{
    int *ptr = 125;    // 125번지가 어딘 줄 알고?
    *ptr = 10;
    ...
}
```
위의 경우는 포인터 변수 ptr을 초기화 한답시고 125를 저장하였다. 그러나 더 우스운 꼴이 되 어버리고 말았다.  
125번지가 어딘 줄 알고 포인터 변수를 125로 초기화하는가? 결국 이는 쓰레기 값으로 포인터 변수를 초기화한 것과 다르지 않다.  
<br/><br/>

### 포인터 초기화
#### 그렇다면 포인터 변수는 어떤 값으로 초기화를 시켜야 하나?
포인터 변수를 우선 선언만 해놓고, 이후에 유효한 주소 값을 채워 넣을 생각이라면 다음과 같이 초기화를 하는 것이 좋다. 
```
int main(void)
{
    int *ptr1 = 0;
    int *ptr2 = NULL;    // NULL은 사실상 0을 의미함
    ...
}
```
위에서 ptr1을 초기화 하는 값 0을 가리켜 ***널 포인터***라 한다. 이는 0번지를 의미하는 것이 아니다.  
```
아무데도 가리키지 않는다!!
```
따라서 이를 이용한 `*`연산은 메모리 공간에 어떠한 영향도 미치지 않는다. 물론 프로그램이 멈추는 현상은 동일하게 일어나지만,  
이는 잘못된 메모리의 접근에 대해 보호장치가 없는 운영체제에서도 시스템에 치명적인 영향을 주지 않는다.  
그리고 **키워드 `NULL`은  널 포인터를 의미하며, 실제로 이는 상수 0으로 정의되어 있다.**  
<br/><br/>

---
<br/><br/>

## 3) void 포인터
### 함수 포인터의 이해
변수만 메모리 공간에 저장되는 것은 아니다.  
프로그램 실행의 흐름을 구성하는 **함수**들도 바이너리 형태로 메모리 공간에 저장되어서 호출 시 실행이 된다.  
그리고 이렇게 메모리상에 저장된 **함수의 주소 값을 저장하는 포인터 변수**가 바로 **함수 포인터 변수**이다.  

프로그래머가 정의하는 모든 함수는 프로그램 실행 시 '메인 메모리'에 저장되어 실행된다.  
그리고 **함수의 이름은, 메모리상에 저장된 함수의 주소 값**을 의미한다.  
**배열의 이름이 배열의 시작주소 값을 의미하듯, 함수의 이름도 함수가 저장된 메모리 공간의 주소 값을 의미**하는 것이다.  

물론 배열의 이름과 마찬가지로 함수의 이름도 그 형태가 상수이다. 그런데 이러한 함수의 주소 값 저장을 위한 포인터 변수를 별도로 선언할 수 있으며,  
이러한 용도로 선언된 포인터 변수를 가리켜 `함수 포인터 변수`라 한다.  
<br/>

#### - 함수 포인터 변수의 선언 방법
먼저, 함수 포인터의 포인터 형을 결정한다.  
모든 변수가 그러하듯 형을 결정하지 못한다면 적절한 함수 포인터 변수의 선언은 불가능하다. 이와 관련해서 다음 함수를 보자.  
```
int SimpleFunc(int num){...}
```
이 함수의 반환형은 `int`, 매개변수 선언은 `int num` 이다.  
그리고 이 상황에서 **함수의 이름 `SimpleFunc`은 `SimpleFunc` 함수의 주소 값을 의마하는 상수형태의 함수 포인터**가 된다.  

그렇다면 SimpleFunc의 형(type)은 뭘까?
함수 포인터의 형(type)은 반환형과 매개변수의 선언형태를 기준으로 구분하기로 약속하자!  
간단히 말하면 **함수이름의 포인터 형은 반환형과 매개변수의 선언을 통해서 결정짓도록 약속되어 있다.**  
즉 앞서 보인 함수를 대상으로 함수이름 SimpleFunc의 포인터 형을 말해보면,
```
반환형이 int이고, 매개변수로 int형 변수가 하나 선언된 포인터 형(type)이다.
```
이렇듯 누군가 함수 포인터의 형을 물어보면 반환형과 매개변수의 선언형태를 말해주면 된다. 
또 다른 예로, 아래와 같은 함수 포인터의 형은
```
double ComplexFunc(double num1, double num2){...}

반환형이 double이고 매개변수로 두 개의 double형 변수가 선언된 포인터 형(type)이다.
```
<br/><br/>

#### - 적절한 함수 포인터 변수의 선언
그렇다면 함수의 주소 값(함수 포인터의 값)을 저장할 수 있는 포인터 변수는 어떻게 선언할까?  
**이 포인터 변수에는 반환형 정보와 매개변수 선언의 정보가 모두 표현되어 있어야 한다.**  
따라서 다음과 같이 의미를 부여하여 함수 포인터 변수를 선언하기로 약속되어 있다.  
```
int (*fptr)(int)


(*fptr) : fptr은 포인터!
int     : 반환형이 int인 함수 포인터
(int)   : 매개변수 선언이 int 하나인 함수 포인터!
```
그럼 다음 함수를 대상으로 예를 들어보겠다.  
```
int SoSimple(int num1, int num2){...}
```
이 함수는 반환형이 int형이고 매개변수로 int형 변수가 두 개 선언되었으니,  
이 함수의 주소 값 저장을 위한 함수 포인터 변수는 다음과 같이 선언하면 된다.  
```
int (*fptr)(int, int);
```
그리고 이 함수 포인터 변수에 함수 `SoSimple`의 주소 값을 저장하려면 다음과 같이 **대입연산**을 진행하면 된다.
```
fptr = SoSimple;
```
이렇듯 대입연산이 끝나고 나면 fptr과 SoSimple에는 동일한 값이 저장되어, 상수냐 변수냐가 이 둘의 유일한 차이점이 된다.  
따라서 `fptr`을 이용해서도 다음과 같이 `SoSimple` 함수를 호출할 수 있다.  
```
fptr(3, 4);    // SoSimple(3, 4)와 동일한 결과를 보임
```
<br/><br/>

#### - 예제1
```c
#include <stdio.h>

void SimpleAdder(int n1, int n2)
{
    printf("%d + %d = %d \n", n1, n2, n1 + n2);
}

void ShowString(char *str)
{
    printf("%s \n", str);
}

int main(void)
{
    char *str = "Function Pointer";
    int num1 = 10, num2 = 20;
    
    void (*fptr1)(int, int) = SimpleAdder;
    void (*fptr2)(char *) = ShowString;
    
    /* 함수 포인터 변수에 의한 호출 */
    fptr1(num1, num2);
    fptr2(str);
    return 0;
}
```
```
10 + 20 = 30
Function Pointer
```
<br/><br/>

#### - 예제 2
이 예제에서는 **매개변수의 선언으로 함수 포인터 변수가 올 수 있음**을 보이고,  
더불어서 전달되는 인자에 따라서 달리 동작하는 함수의 정의도 가능함을 보이고자 한다.  
```
#include <stdio.h>

int WhoIsFirst(int age1, int age2, int (*cmp)(int n1, int n2))    // 전달되는 인자에 따라 달리 동작하는 함수 
{
    return cmp(age1, age2);
}

int OlderFirst(int age1, int age2)
{
    if (age1 > age2)
        return age1;
    else if (age1 < age2)
        return age2;
    else 
        return 0;
}

int YoungerFirst(int age1, int age2)
{
    if (age1 < age2)
        return age1;
    else if (age1 > age2)
        return age2;
    else 
        return 0;    
}

int main(void)
{
    int age1 = 20;
    int age2 = 30;
    int first;
    
    printf("입장순서 1 \n");
    first = WhoIsFirst(age1, age2, OlderFirst);
    printf("%d세와 %d세 중 %d세가 먼저 입장! \n\n", age1, age2, first);
    
    printf("입장순서 2 \n");
    first = WhoIsFirst(age1, age2, YounferFirst);
    printf("%d세와 %d세 중 %d세가 먼저 입장! \n\n", age1, age2, first);   
}
```
> ##### 3행 :  
> 매개변수의 선언으로도 함수 포인터가 올 수 있다. 따라서 이 함수를 호출할 때에는 세번째 인자로,  
> 반환형이 int이고 두 개의 int형 변수가 매개변수로 선언된 함수의 이름(함수의 주소 값)이 전달되어야 한다.  
> ##### 5행 :  
> 첫 번째, 두 번째 인자를 재 전달히면서 세 번째 인자로 전달된 함수를 호출하고 있다.  
> 그리고 이 때 반환되는 값을 재 반환하고 있다. 결과적으로 **세번째 인자로 어떠한 함수의 주소 값이 전달되느냐에 따라서  
> 함수 `WhoIsFirst`의 동작방식이 결정된다.**  

```
// 실행 결과

입장순서 1
20세와 30세 중 30세가 먼저 입장!

입장순서 2
20세와 30세 중 20세가 먼저 입장
```
위 예제에서 보이듯 함수 포인터를 통해서 함수의 동작 방식에 유연성을 제공할 수도 있다.  
<br/><br/>

### '형(Type)'이 존재하지 않는 void 포인터
다음과 같이 선언되는 포인터 변수를 가리켜 `void`형 포인터 변수라 한다.  
void형 포인터 변수는 무엇이든 담을 수 있는 바구니에 비유할 수 있다. **어떠한 변수의 주소 값이든 담을 수 있다.**  
하다못해 함수의 주소 값도 담을 수 있다.  
```
#include <stdio.h>

void SoSimpleFunc(void)
{
    printf("I'm so simple")
}

int main(void)
{
    int num = 20;
    void *ptr;     
    
    ptr = &num;    // 변수 num의 주소 값 저장
    printf("%p \n", ptr);
    
    ptr = SoSimpleFunc;    // 함수 SoSimpleFunc의 주소 값 저장
    printf("%p \n", ptr);
    return 0;
}
```
```
001AF974
00F61109
```
위 예제에서 무엇이든 담을 수 있으니 좋게만 느껴지나? 하지만 단점도 있다.  
`void`형 포인터 변수를 가지고는 아무런 포인터 연산을 하지 못한다. **값의 변경이나 참조도 불가능하다.**  
`void`형 포인터 변수에는 가리키는 대상에 대한 어떠한 형(tpye) 정보도 담겨있지 않으므로 이는 당연한 것이다.  

따라서 아래의 코드를 컴파일 하면 에러가 발생한다.  
```
int main(void)
{
    int num = 20;
    void *ptr = &num;
    *ptr = 20;    // 컴파일 에러
    ptr++;        // 컴파일 에러
}
```
그래서 void형 포인터는 다음의 상황 또는 유사한 형태의 전략이 필요한 경우에 유용하게 사용된다.  
> **일단 주소 값에만 의미를 두고, 포인터의 형은 나중에 결정한다.**  
> 또한 메모리의 동적 할당을 잘 이해하려면 void형 포인터의 존재를 알고 있어야 한다.  

<br/><br/>

---
<br/><br/>
 
## 7. 기타 세부 사항
* 실제 학습 시간 : 4시간 
* 학습에 참고한 사이트 : 윤성우 열혈 C프로그래밍 
    * 널 포인터 : p.284
    * void 포인터 : p.392

<br/>

## 8. 학습 내용에 대한 개인적인 총평
함수를 구현하면서 궁금해진 개념들을 정리했다. memset함수는 `void` 포인터를 반환하고 `void` 포인터를 인자로 받았는데, 이 void 포인터란 어떤 변수의 주소값도 담을 수 있는 변수이다. 그리고 null 포인터가 궁금해졌던 것은 strchr 함수 구현할 때, 일치하는 문자가 없으면 null 포인터를 반환해야 했기 때문이다. 이 null포인터는 아무것도 가리키지 않는다는 의미를 담고 있다. 예전에 공부하던 책을 참고했는데, 인터넷으로 사람들이 정리해놓은 것보다 깔끔하고 이해하기 쉬웠다. 요즘 느끼는 건데 인터넷으로 검색하다보면 틀린 정보들도 꽤 있어서, 잘못된 지식을 습득하는 경우도 있었다. strlcat 함수 공부했을 때 정리했던 것이 지금 다시보니 틀린 부분이 있는 것 같다. 다음 시간 에는 strlcat 반환값을 간단하게 정리하고 함수를 구현해보려 한다.  
<br/>

## 9. 다음 학습 계획
- strlcat 함수 구현
