## 목차
- [1. 학습 날짜](#1-학습-날짜)  
- [2. 학습 시간](#2-학습-시간)  
- [3. 학습 범위 및 주제](#3-학습-범위-및-주제)  
- [4. 동료 학습 방법](#4-동료-학습-방법)  
- [5. 학습 목표](#5-학습-목표)  
- [6. 상세 학습 내용](#6-상세-학습-내용)  
    - [C언어의 메모리 구조](#c언어의-메모리-구조)
        - [메모리의 구성](#--메모리의-구성)
        - [메모리 영역별로 저장되는 데이터 유형](#--메모리-영역별로-저장되는-데이터-유형)
        - [프로그램의 실행에 따른 메모리의 상태 변화](#--프로그램의-실행에-따른-메모리의-상태-변화)
    - [메모리의 동적 할당](#메모리의-동적-할당)
        - [전역변수와 지역변수로 해결이 되지 않는 상황](#--전역변수와-지역변수로-해결이-되지-않는-상황)
        - [힙 영역 메모리 공간 할당과 해제 : malloc과 free 함수](#--힙-영역-메모리-공간-할당과-해제-malloc과-free-함수)
- [7. 실제 학습 시간 및 참고 사이트](#7-기타-세부-사항)
- [8. 학습 내용에 대한 개인적인 총평](#8-학습-내용에-대한-개인적인-총평)
- [9. 다음 학습 계획](#9-다음-학습-계획)  

<br/> 

## 1. 학습 날짜
* 2021-02-21(일)<br/><br/>
## 2. 학습 시간
* 19:00 ~ 22:00(자가)<br/><br/>
## 3. 학습 범위 및 주제
* C언어의 메모리 구조를 살펴본다.
* malloc을 사용하기 위해 메모리의 동적할당 개념을 학습한다.<br/><br/>
## 4. 동료 학습 방법
* 해당 사항 없음<br/><br/>
## 5. 학습 목표
* 메모리 구조를 이해하고, 동적 할당의 개념에 대해 학습한다.<br/><br/>
## 6. 상세 학습 내용
## C언어의 메모리 구조
프로그램을 실행하면 해당 프로그램의 실행을 위한 메모리 공간이 운영체제에 의해서 미리 마련이 된다.  
그리고 바로 이 메모리 공간 내에서 변수가 선언되고, 문자열이 선언되는 것이다.  
<br/>

### - 메모리의 구성
프로그램 실행 시 운영체제에 의해서 마련되는 메모리의 구조는 다음과 같이 네개의 영역으로 구분이 된다.  
<center><img src ="https://mblogthumb-phinf.pstatic.net/20160306_230/sonicheroes1_1457268789146SJll3_PNG/%B0%AD%C0%C7_25-1%281%29.png?type=w2"></center>  

<br/><br/>

이렇듯 메모리 공간을 나눠놓은 이유는 커다란 서랍장의 수납 공간이 나뉘어 있는 이유와 유사하다고 할 수 있다.  
**메모리 공간을 나눠서 유사한 성향의 데이터를 묶어 저장을 하면, 관리가 용이해지고 메모리의 접근속도가 향상된다.**  
서랍장의 수납공간이 나뉘어 있으면, 물건을 찾을 때 한결 수월한 것처럼 메모리 공간을 나눠놓은 이유는 매우 단순하다.  
<br/><br/>

### - 메모리 영역별로 저장되는 데이터 유형
각 영역별 특성에 대해 구체적으로 살펴보자.
#### 1) 코드 영역
코드 영역은 이름 그대로 실행할 프로그램의 코드가 저장되는 메모리 공간이다.  
따라서 CPU는 코드 영역에 저장된 명령문들을 하나씩 가져가서 실행을 한다.  
<br/>

#### 2) 데이터 영역
데이터 영역에는 전역변수와 static으로 선언되는 `static` 변수가 할당된다.  
즉, 이 영역에 할당되는 변수들은 프로그램 시작과 동시에 메모리 공간에 할당되어 **프로그램 종료시까지 남아있게 된다는 특징이 있다.**  
<br/>

#### 3) 스택 영역
스택영역에는 **지역변수와 매개변수가 할당**된다.  
이렇듯, 이 영역에 할당되는 변수들은 선언된 **함수를 빠져나가면 소멸된다는 특징**이 있다.  
<br/>

#### 4) 힙 영역(Heap Area)
데이터 영역에 할당되는 변수와 스택 영역에 할당되는 변수들은 생성과 소멸의 시점이 이미 결정되어 있다.  
그러나 프로그램을 구현하다 보면 **프로그래머가 원하는 시점에 변수를 할당하고 또 원하는 시점에 해제할 필요가 있다.**  
이러한 유형의 변수들이 할당되는 영역이 힙 영역이다.  
<br/><br/>

### - 프로그램의 실행에 따른 메모리의 상태 변화
프로그램의 실행과정에서 보이는 메모리 공간의 변화를 통해 각 영역별 특징에 대해 다시 한번 정리하겠다.  
단 코드 영역은 변수가 할당되는 영역이 아니니 생략을 하고 설명을 진행하겠다.  
다음은 왼편의 코드가 실행된 직후의(main 함수가 호출되기 직전) 상황을 보이고 있다.  

<center><img src ="https://mblogthumb-phinf.pstatic.net/20160306_210/sonicheroes1_1457271548292wNafw_PNG/C_25-1%283%29.png?type=w2"></center>  

<br/>

지금까지는 '프로그램의 시작은 main 함수의 호출에서부터다!'라고 이야기해 왔지만, 실제로는 main 함수가 호출되기 이전에 **데이터 영역이 먼저 초기화**된다.  
위와 같이 전역변수가, 그리고 여기에는 없지만 `static` 변수가 먼저 데이터 영역에 할당이 되고 나서 `main` 함수가 호출된다.  
이어서 main 함수가 호출되고 main 함수 내에 선언된 지역변수 `num1`이 스택에 할당되어 다음의 구조가 된다.  
<br/>

<center><img src ="https://mblogthumb-phinf.pstatic.net/20160306_78/sonicheroes1_14572716827564Fg7C_PNG/C_25-1%284%29.png?type=w2"></center>  

<br/>

다음으로 `main` 함수 내에서 `fct` 함수가 호출된다.  
때문에 fct 함수의 **매개변수가 스택에 할당**되고 fct 함수의 지역변수도 다음에서 보이듯이 그 뒤를 이어 할당된다.  

<center><img src="https://mblogthumb-phinf.pstatic.net/20160306_220/sonicheroes1_14572717404436exQC_PNG/C_25-1%285%29.png?type=w2"></center>  

<br/>

다음으로 fct 함수가 반환을 하면서 **fct 함수호출 시 할당되었던 매개변수와 지역변수가 소멸**되면서 다음의 형태가 된다.  
참고로 다음 그림에서는 fct 함수를 빠져 나온 이후에 main 함수 내에서 num1의 값이 증가한 상황까지의 결과를 보이고 있다.  

<center><img src="https://mblogthumb-phinf.pstatic.net/20160306_256/sonicheroes1_1457271791279GbvIx_PNG/C_25-1%286%29.png?type=w2"></center>  

<br/>

이어서 다시 fct 함수 호출이 진행되고, 매개변수와 지역변수가 다시 스택에 할당되어 다음의 구조가 된다.  

<center><img src="https://mblogthumb-phinf.pstatic.net/20160306_78/sonicheroes1_14572719611945BSwl_PNG/C_25-1%287%29.png?type=w2"></center>  

<br/>

마지막으로 fct 함수가 반환되고, main 함수의 `return` 문이 실행되면서 프로그램이 종료된다.  
그리고 프로그램이 종료되면, 운영체제에 의해서 할당된 메모리 공간 전체를 반환하게 되는데, 바로 그때가 **전역변수가 소멸되는 시점**이다.  

<center><img src="https://mblogthumb-phinf.pstatic.net/20160306_107/sonicheroes1_1457273130690Km2xT_PNG/C_25-1%288%29.png?type=w2"></center>  

<br/><br/>

지금까지 살표 본 내용을 기준으로 스택 영역의 특징을 하나 더 찾아보면, 다음 순서로 함수가 호출되었다고 가정할 때
```
main 함수의 호출 -> fct1 함수의 호출 -> fct2 함수의 호출
```
이는 fct1 함수가 반환된 이후에 fct2 함수가 호출되었다는 뜻이 아니고, fct1 함수 내에서 fct2 함수가 호출되었다는 뜻이다.  
그리고 이러한 경우에 지역(매개)변수의 소멸순서는 다음과 같다.  
```
fct2의 지역변수 소멸 -> fct1의 지역변수 소멸 -> main의 지역변수 소멸
```
이렇듯 **먼저 호출된 함수의 스택공간일수록 늦게 해제된다**는 것을 알 수 있다. 그래서 메모리 영역의 이름이 스택(Stack : 쌓아 올려진 더미)이다.  
쟁반 위에 접시를 쌓아 올리고 나서, 위에서 부터 접시를 하나씩 내려 놓는다고 생각해 보자. 가장 아래에 위치한 접시가 마지막에 내려질 것이다.  
그리고 이는 지금까지 설명한 스택 영역과 일치하는 특성이다.  
<br/><br/>

---
<br/><br/>

## 메모리의 동적 할당
프로그램을 구현하다 보면 전역변수, 지역변수 외에도 다른 유형의 변수를 필요로 하게 된다.  
### - 전역변수와 지역변수로 해결이 되지 않는 상황
- 프로그램 사용자로부터 입력받은 문자열의 정보를 반환하는 함수
```c
// ReadStringFault1.c

#include <stdio.h>

char *ReadUserName(void)
{
    char name[30];
    printf("What's your name? ");
    gets(name);
    return (name);    // 무엇을 반환하는가?
}

int main(void)
{
    char *name1;
    char *name2;
    name1 = ReadUserName();
    printf("name1 : %s \n", name1);
    name2 = ReadUserName();
    printf("name2 : %s \n", name2);
    return 0;
}
```
이 예제의 문제점은 뭘까? 그것은 함수 내에 지역적으로 선언된 배열(변수)의 주소 값을 반환하는데 있다.  
함수 내에서 프로그램 사용자로부터 문자열을 입력 받아서 그 결과를 반환하는 것은 좋다.  
문제는 그 문자열이 저장되어 있는 **배열이 지역적으로 선언되었기 때문에 함수를 빠져나오면서 소멸**된다는데 있다.  
그래서 실행을 해보면 정상적이지 못한 결과로 이어지는 것을 확인할 수 있다.  
<br/>

- 전역변수를 이용해서 해결할 수 있을까?
```
// ReadStringFault2.c

#include <stdio.h>
char name[30];

char *ReadUserName(void)
{
    printf("What's your name? ");
    gets(name);
    return (name);    // 무엇을 반환하는가? 배열의 주소값
}

int main(void)
{
    char *name1;
    char *name2;
    name1 = ReadUserName();
    printf("name1 : %s \n", name1);
    name2 = ReadUserName();
    printf("name2 : %s \n", name2);
    
    printf("name1: %s \n", name1);
    printf("name2: %s \n", name2);
    return 0;
}
```
```
What's your name? Yoon sung woo
name1: YOon sung woo
What's your name? Choi jun kyung
name2: Choi jun kyung
name1: Choi jun kyung
name2: Choi jun kyung
```
위의 실행결과에서 보이듯이 **하나의 전역변수(전역으로 선언된 배열)을 이용하면, 이 전역변수를 덮어쓰게 되기 때문에**,   
함수호출을 통해서 얻게 된 이름정보가 유지되지 않는다.

> **name1**에는 처음에 **name**(전역 변수)의 주소값이 저장되어 있다. 여기에 윤성우라는 이름이 입력된 것이고,  
> 그 다음 **name2**에도 마찬가지로 **name**의 주소값이 저장되어 있는데, 여기에 최준경이라는 이름이 입력되면,  
> **name**은 최준경이라는 이름을 최종적으로 담게 된다. 즉, **name**의 주소값을 담고 있던 **name1**도 최준경이라는 이름을 담는 것이다.  

<br/>

프로그램 사용자에게서 이름정보를 입력 받아서 이를 반환하는 함수를 정의하기에는 지역변수도 전역변수도 답이 될 수 없다.  
아래와 같은 성격의 변수가 필요하다.  
```
"함수가 매번 호출될 때마다 새롭게 할당되고 또 함수를 빠져나가도 유지가 되는 유형의 변수"
```
다시 말해서, **지역변수와 같이 함수가 호출될 때마다 매번 할당**이 이뤄지지만,  
할당이 되면 **전역변수와 마찬가지로 함수를 빠져나가도 소멸되지 않는 성격**의 변수가 필요하다.  
**생성과 소멸의 시기가 지역변수나 전역변수와 다른 유형의 변수**는 `malloc`과 `free`라는 이름의 함수를 통해서 **힙 영역**에 할당하고 소멸할 수 있다.  
<br/><br/>

### - 힙 영역 메모리 공간 할당과 해제 : malloc과 free 함수
아래에서 보이는 `malloc` 함수를 이용해서 메모리 공간을 할당하고, 할당된 메모리 공간은 `free` 함수의 호출을 통해서 해제한다.  
```
#include <stdlib>

void *malloc(size_t size);    // 힙 영역으로의 메모리 공간 할당
void free(void *ptr);         // 힙 영역에 할당된 메모리 공간 해제

// malloc 함수는 성공시 할당된 메모리의 주소 값을 반환하고, 실패시 NULL 반환
```
힙 영역을 흔히 **프로그래머가 관리하는 메모리 공간**이라고 한다.  
이유는 malloc 함수호출로 할당된 메모리 공간은 프로그래머가 직접 free 함수의 호출을 통해서 해제하지 않으면 계속 남아있기 때문이다.  
즉 위의 두 함수는 다음과 같이 쌍을 이루어 호출하게 된다.  
```
int main(void)
{
    void *ptr1 = malloc(4);    // 4 바이트가 힙 영역에 할당
    void *ptr2 = malloc(12);   // 12 바이트가 힙 영역에 할당
    ...
    free(ptr1);    // ptr1이 가리키는 4바이트 메모리 공간 해제
    free(ptr2);    // ptr2이 가리키는 12바이트 메모리 공간 해제
    ...
}
```
이렇듯 `malloc`함수는 **인자로 전달된 정수 값에 해당하는 바이트 크기의 메모리 공간을 힙 영역에 할당하고, 이 메모리 공간 주소 값을 반환한다.**  
따라서 위의 코드를 실행하게 되면 ptr1은 첫 번째 malloc 함수 호출을 통해서 할당된 메모리 공간의 첫 번째 바이트를 가리키게 되고,
ptr2는 두 번째 malloc 함수호출을 통해서 할당된 메모리 공간의 첫 번째 바이트를 가리키게 된다.  

이어서 ptr1을 인자로 `free` 함수를 호출하는 시점에 ptr1이 가리키는 메모리 공간이 소멸되고,  
ptr2를 인자로 `free` 함수를 호출하는 시점에 ptr2가 가리키는 메모리 공간이 소멸된다.  
무엇보다도 malloc 함수와 free 함수의 호출위치 및 시점에는 제한이 없다.  

> 힙 영역에 할당된 메모리 공간은 포인터 변수를 이용해서 접근하는 방법 밖에 없나?  
> malloc 함수는 **주소 값을 반환**한다. 그리고 그 주소 값을 이용해서 힙에 접근을 해야 한다.  
> 따라서 포인터를 이용해서 메모리 공간에 접근하는 수밖에 없다.

<br/><br/>

---
<br/><br/>

## 7. 기타 세부 사항
* 실제 학습 시간 : 3시간 
* 학습에 참고한 사이트 :
    * [C언어의 메모리 구조](https://m.blog.naver.com/PostView.nhn?blogId=sonicheroes1&logNo=220647466481&proxyReferer=https:%2F%2Fwww.google.co.kr%2F)
    * 윤성우의 c프로그래밍 p.542

<br/>

## 8. 학습 내용에 대한 개인적인 총평
앞서 함수 몇개를 구현해 보았는데, 함수가 종료되면 사라지는 지역변수에 대해 헷갈리는 부분이 좀 있었다. 특히 포인터를 사용할 때 더 그랬던 것 같다. 함수 (main 함수가 아닌) 안에서 포인터 변수를 선언하면 그 함수가 종료됨과 동시에 그 포인터 변수는 스택 영역에서 소멸된다는 점을 잘 알아두어야 겠다. 그러나 매개변수로 주소값을 받아 함수 내에서 사용하면 swap 함수와 같이 실제 그 주소에 접근해서 값을 변경할 수 있다. 이런 점이 좀 혼란스러운데, 포인터에 대한 이해가 아직 부족하게 느껴진다. 지난 시간에 strlcat 함수 구현을 하면서 고려했던 점 중 마지막 5번째 부분을 보면, src의 주소값을 직접적으로 변경했다 이런 내용을 적어놨었다. 내가 함수 내에서 src의 주소값을 바꿔가며 값에 접근을 하고 그 함수를 종료하면 src의 위치가 처음 매개변수로 받았던 위치가 아니라 내가 값을 참조하기 위해 변경했던 주소 값이 저장될 줄 알았다. 그러나 실제 여러가지 케이스로 출력을 해보니 src의 주소 값은 처음과 동일했다. 이것을 오늘 공부한 것과 연관지어 생각하면 strlcat의 매개변수 src는 함수내의 지역변수일 뿐이고, 스택영역에 할당되었다가, 이 함수가 종료됨과 동시에 src는 소멸된다. main 함수 내에서 배열을 src라는 이름으로 설정하고, strlcat 매개변수의 이름도 src라고 설정해서 더 헷갈렸던 것 같다.   
<br/>

## 9. 다음 학습 계획
- strnstr, strncmp 함수를 구현한다.  
